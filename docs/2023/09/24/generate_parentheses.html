<!DOCTYPE html>
<html lang="">

  <head>
  <meta charset="UTF-8">
  <title>Algorithmics</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/assets/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/assets/css/theme.css">
  <link rel="stylesheet" href="/assets/css/tags.css">
  <link rel="stylesheet" href="/assets/css/tabs.css">
  <link rel="icon" type="image/x-icon" href="/assets/favicon.ico">
</head>


  <body>
    <section class="page-header">
    <a href="/">
        <img src="/assets/images/logo.jpg" alt="Algorithmics" class="logo">
    </a>

    <h1 class="project-name">Algorithmics</h1>
    <h2 class="project-tagline"></h2>

    <div>
        <a href="https://github.com/avivasyuta/algorithmics" target="_blank" class="btn">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                <path fill="currentColor" fill-rule="evenodd"
                      d="M11.999 1C5.926 1 1 5.925 1 12c0 4.86 3.152 8.983 7.523 10.437c.55.102.75-.238.75-.53c0-.26-.009-.952-.014-1.87c-3.06.664-3.706-1.475-3.706-1.475c-.5-1.27-1.221-1.61-1.221-1.61c-.999-.681.075-.668.075-.668c1.105.078 1.685 1.134 1.685 1.134c.981 1.68 2.575 1.195 3.202.914c.1-.71.384-1.195.698-1.47c-2.442-.278-5.01-1.222-5.01-5.437c0-1.2.428-2.183 1.132-2.952c-.114-.278-.491-1.397.108-2.91c0 0 .923-.297 3.025 1.127A10.536 10.536 0 0 1 12 6.32a10.49 10.49 0 0 1 2.754.37c2.1-1.424 3.022-1.128 3.022-1.128c.6 1.514.223 2.633.11 2.911c.705.769 1.13 1.751 1.13 2.952c0 4.226-2.572 5.156-5.022 5.428c.395.34.747 1.01.747 2.037c0 1.47-.014 2.657-.014 3.017c0 .295.199.637.756.53C19.851 20.979 23 16.859 23 12c0-6.075-4.926-11-11.001-11"/>
            </svg>
            GitHub
        </a>

        <a href="https://t.me/algorithmics_cl" target="_blank" class="btn">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                <path fill="none" stroke="currentColor" stroke-width="2"
                      d="M22 3L2 11l18.5 8L22 3ZM10 20.5l3-4.5m2.5-6.5L9 14l.859 6.012c.078.546.216.537.306-.003L11 15l4.5-5.5Z"/>
            </svg>
            Telegram
        </a>
    </div>
</section>


    <section class="main-content">

      <a class="back" href="/">
    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 2048 2048">
        <path fill="currentColor"
              d="m1699 249l-775 775l775 775l-241 242L441 1024L1458 7l241 242z"/>
    </svg>
    На главную
</a>

<h1>Генерация валидной скобочной последовательности (один вид скобок)</h1>

<p class="meta">
    24 September 2023, Сложность

    

    
    <span class="medium-complexity">Средняя</span>
    

    
    ,

    
    

    <span>
        1 min
    </span>
</p>


<p>
    <a href="https://leetcode.com/problems/generate-parentheses/" target="_blank">Оригинал задачи на Leetcode</a>
</p>


<h2 id="оглавление">Оглавление</h2>

<ul>
  <li><a href="#описание-задачи">Описание задачи</a></li>
  <li><a href="#ограничения">Ограничения</a></li>
  <li><a href="#примеры">Примеры</a></li>
  <li><a href="#брутфорс-решение">Брутфорс решение</a></li>
  <li><a href="#оптимизированный-брутфорс">Оптимизированный брутфорс</a></li>
</ul>

<hr />

<h2 id="описание-задачи">Описание задачи</h2>

<p>Напишите функцию, которая будет генерировать все возможные валидные скобочные последовательности длиной <code class="language-plaintext highlighter-rouge">2n</code>.</p>

<p>Входные данные: int — количество пар скобок.</p>

<p>Выходные данные: массив строк — все возможные валидные скобочные последовательности длиной <code class="language-plaintext highlighter-rouge">2n</code>.</p>

<hr />

<h2 id="ограничения">Ограничения</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= n &lt;= 8</code></li>
</ul>

<hr />

<h2 id="примеры">Примеры</h2>

<ul id="generate_parentheses" class="tab" data-tab="e1907332-549a-4846-b77d-223ed240caf7" data-name="generate_parentheses">
  
      <li class="active" id="--------1">
          <a href="#">Пример №1 </a>
      </li>
  
      <li id="--------2">
          <a href="#">Пример №2 </a>
      </li>
  
</ul>
<ul class="tab-content" id="e1907332-549a-4846-b77d-223ed240caf7" data-name="generate_parentheses">
  
      <li class="active">
<p><strong>Входные данные</strong>: <code class="language-plaintext highlighter-rouge">3</code></p>

<p><strong>Ответ</strong>: <code class="language-plaintext highlighter-rouge">["((()))", "(()())", "(())()", "()(())", "()()()"]</code></p>
</li>
  
      <li>
<p><strong>Входные данные</strong>: <code class="language-plaintext highlighter-rouge">1</code></p>

<p><strong>Ответ</strong>: <code class="language-plaintext highlighter-rouge">["()"]</code></p>
</li>
  
</ul>

<hr />

<h2 id="брутфорс-решение">Брутфорс решение</h2>

<p>Давайте разобьем задачу на 2 подзадачи:</p>
<ul>
  <li>генерация всех возможных строк длиной 2n, состоящих из символов <code class="language-plaintext highlighter-rouge">(</code> и <code class="language-plaintext highlighter-rouge">)</code>;</li>
  <li>проверка строк на то, что они являются валидными скобочными последовательностями.</li>
</ul>

<h3 id="генерация-всех-возможных-строк-длиной-2n-состоящих-из-символов--и-">Генерация всех возможных строк длиной 2n, состоящих из символов «(» и «)»</h3>

<p>Достаточно тривиальная задача:</p>
<ul>
  <li>Создаем исходный массив. В нашем случае из одного элемента, так как валидная скобочная последовательность может начинаться только с открывающей скобки.</li>
  <li>Запускаем цикл до <code class="language-plaintext highlighter-rouge">2 * n</code>, где <code class="language-plaintext highlighter-rouge">n</code> — количество пар скобок.</li>
  <li>В каждой итерации цикла проходимся по всем элементам предыдущего результата и добавляем 2 новых варианта с открывающей и закрывающей скобками.</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">generateAllPossibleParenthesis</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
    <span class="n">combinations</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">100</span><span class="p">)</span>
    <span class="n">combinations</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">combinations</span><span class="p">,</span> <span class="s">"("</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">*</span><span class="m">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">newArray</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">combinations</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">combinations</span> <span class="p">{</span>
            <span class="n">newArray</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">newArray</span><span class="p">,</span> <span class="n">item</span><span class="o">+</span><span class="s">"("</span><span class="p">)</span>
            <span class="n">newArray</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">newArray</span><span class="p">,</span> <span class="n">item</span><span class="o">+</span><span class="s">")"</span><span class="p">)</span>
        <span class="p">}</span>
        
        <span class="n">combinations</span> <span class="o">=</span> <span class="n">newArray</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">combinations</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="проверка-строки-на-валидную-скобочную-последовательность">Проверка строки на валидную скобочную последовательность</h3>

<p>Эту задачу мы уже разбирали.
Чтобы не повторяться, возьмем готовое <a href="/2023/09/20/valid_parentheses.html">решение</a> для проверки валидности скобочной последовательности.</p>

<p>В результате получим следующие решения.</p>

<ul id="solution" class="tab" data-tab="11cf2616-67b0-4b35-9c4c-c15ff246d87e" data-name="solution">
  
      <li class="active" id="go">
          <a href="#">go </a>
      </li>
  
      <li id="type-script">
          <a href="#">type script </a>
      </li>
  
</ul>
<ul class="tab-content" id="11cf2616-67b0-4b35-9c4c-c15ff246d87e" data-name="solution">
  
      <li class="active">
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">func</span> <span class="n">generateParenthesisBruteforce</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="n">combinations</span> <span class="o">:=</span> <span class="n">generateAllPossibleParenthesis</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
	<span class="n">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">combinations</span><span class="p">))</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">parenthesis</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">combinations</span> <span class="p">{</span>
		<span class="k">if</span> <span class="o">!</span><span class="n">isValid</span><span class="p">(</span><span class="n">parenthesis</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="n">res</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">parenthesis</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">generateAllPossibleParenthesis</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="n">combinations</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">100</span><span class="p">)</span>
	<span class="n">combinations</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">combinations</span><span class="p">,</span> <span class="s">"("</span><span class="p">)</span>

	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">*</span><span class="m">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">newArray</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">combinations</span><span class="p">))</span>
		<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">combinations</span> <span class="p">{</span>
			<span class="n">newArray</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">newArray</span><span class="p">,</span> <span class="n">item</span><span class="o">+</span><span class="s">"("</span><span class="p">)</span>
			<span class="n">newArray</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">newArray</span><span class="p">,</span> <span class="n">item</span><span class="o">+</span><span class="s">")"</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="n">combinations</span> <span class="o">=</span> <span class="n">newArray</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">combinations</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">isValid</span><span class="p">(</span><span class="n">brackets</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="n">stack</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">rune</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">brackets</span><span class="p">))</span>

	<span class="n">closeBracket</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">rune</span><span class="p">]</span><span class="kt">rune</span><span class="p">{</span>
		<span class="sc">')'</span><span class="o">:</span> <span class="sc">'('</span><span class="p">,</span>
		<span class="sc">']'</span><span class="o">:</span> <span class="sc">'['</span><span class="p">,</span>
		<span class="sc">'}'</span><span class="o">:</span> <span class="sc">'{'</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">char</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">brackets</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">openBracket</span><span class="p">,</span> <span class="n">isClose</span> <span class="o">:=</span> <span class="n">closeBracket</span><span class="p">[</span><span class="n">char</span><span class="p">];</span> <span class="n">isClose</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
				<span class="k">return</span> <span class="no">false</span>
			<span class="p">}</span>

			<span class="n">lastOpenBracket</span> <span class="o">:=</span> <span class="n">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>

			<span class="k">if</span> <span class="n">lastOpenBracket</span> <span class="o">!=</span> <span class="n">openBracket</span> <span class="p">{</span>
				<span class="k">return</span> <span class="no">false</span>
			<span class="p">}</span>

			<span class="n">stack</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">:</span><span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">stack</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">char</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span>
<span class="p">}</span>

</code></pre></div></div>
</li>
  
      <li>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">function</span> <span class="nx">generateParenthesisBruteforce</span><span class="p">(</span><span class="nx">n</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">string</span><span class="p">[]</span> <span class="p">{</span>
	<span class="kd">const</span> <span class="nx">combinations</span> <span class="o">=</span> <span class="nx">generateAllPossibleParenthesis</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
	<span class="kd">let</span> <span class="nx">res</span><span class="p">:</span> <span class="kr">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[]</span>

	<span class="nx">combinations</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">parenthesis</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="nx">isValid</span><span class="p">(</span><span class="nx">parenthesis</span><span class="p">))</span> <span class="p">{</span>
			<span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">parenthesis</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">})</span>

	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">generateAllPossibleParenthesis</span><span class="p">(</span><span class="nx">n</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">string</span><span class="p">[]</span> <span class="p">{</span>
	<span class="kd">let</span> <span class="nx">combinations</span><span class="p">:</span> <span class="kr">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">(</span><span class="dl">"</span><span class="p">]</span>

	<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kd">const</span> <span class="nx">newArray</span><span class="p">:</span> <span class="kr">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[]</span>

		<span class="nx">combinations</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">item</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
			<span class="nx">newArray</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">(</span><span class="dl">"</span><span class="p">)</span>
			<span class="nx">newArray</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">)</span><span class="dl">"</span><span class="p">)</span>
		<span class="p">})</span>

		<span class="nx">combinations</span> <span class="o">=</span> <span class="nx">newArray</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">combinations</span>
<span class="p">}</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">isValid</span> <span class="o">=</span> <span class="p">(</span><span class="nx">brackets</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nx">boolean</span> <span class="o">=&gt;</span> <span class="p">{</span>
	<span class="kd">const</span> <span class="na">stack</span><span class="p">:</span> <span class="kr">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[]</span>

	<span class="kd">const</span> <span class="na">closeBrackets</span><span class="p">:</span> <span class="nb">Record</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">,</span> <span class="kr">string</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
		<span class="dl">'</span><span class="s1">)</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">(</span><span class="dl">'</span><span class="p">,</span>
		<span class="dl">'</span><span class="s1">]</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">[</span><span class="dl">'</span><span class="p">,</span>
		<span class="dl">'</span><span class="s1">}</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">{</span><span class="dl">'</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">brackets</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">brackets</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="kd">const</span> <span class="nx">openBracket</span> <span class="o">=</span> <span class="nx">closeBrackets</span><span class="p">[</span><span class="nx">char</span><span class="p">]</span>

		<span class="k">if</span> <span class="p">(</span><span class="nx">openBracket</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span>

			<span class="kd">const</span> <span class="nx">lastOpenBracket</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">[</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

			<span class="k">if</span> <span class="p">(</span><span class="nx">lastOpenBracket</span> <span class="o">!==</span> <span class="nx">openBracket</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span>

			<span class="nx">stack</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">char</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span>
<span class="p">}</span>


</code></pre></div></div>
</li>
  
</ul>

<h3 id="оценка-сложности">Оценка сложности</h3>

<p><strong>По времени</strong></p>

<p>Оптимальная сложность проверки строки на валидность — <code class="language-plaintext highlighter-rouge">O(n)</code>.
В нашем случае все строки имеют длину <code class="language-plaintext highlighter-rouge">2n</code>, но итоговая сложность все равно будет равна <code class="language-plaintext highlighter-rouge">O(n)</code>.</p>

<p>Давайте оценим количество сгенерированных строк.
Каждый элемент строки кроме первого — произвольный символ из множества [”(“, “)”], а количество символов в итоговой строке <code class="language-plaintext highlighter-rouge">2 * n</code>.
Таким образом, кол-во строк равно <code>2<sup>2n</sup></code>.</p>

<p>Итоговую сложность мы можем оценить как <code>n * (2<sup>2n</sup>)</code>.</p>

<p><strong>По памяти</strong></p>

<p>Самый большой расход памяти в нашем случае — хранение всех возможных строк.
Для этого нам понадобится массив строк, размером <code>2<sup>2n</sup></code>, каждый элемент которого равен <code class="language-plaintext highlighter-rouge">2 * n</code>.
То есть мы можем говорить о <code>n * 2<sup>2n</sup></code> дополнительной памяти.</p>

<blockquote>
  <p>Чаще всего, в задачах с комбинаторикой решение с полным перебором всех возможных вариантов является сильно не оптимальным, так как скорость роста сложности решения относительно размера входных данных очень высока.
Так в этой задаче при n = 8 кол-во всех возможных вариантов строк — <strong>32768</strong> (<code>2<sup>15</sup></code>).</p>
</blockquote>

<hr />

<h2 id="оптимизированный-брутфорс">Оптимизированный брутфорс</h2>

<p>Основная проблема брутфорс решения — генерация большого количества заведомо невалидных строк.
Это можно исправить если мы перед добавлением очередного символа добавим проверки, откидывающие заведомо невалидные символы.</p>

<p>Задача сильно упрощается тем, что в условии сказано, что скобки могут быть только одного типа — круглые.
В этом случае мы можем использовать для валидации последовательности обычный счетчик.
Давайте опишем правила, когда мы можем добавлять разные скобки:</p>
<ul>
  <li>Открывающую скобку мы можем добавить, если суммарное количество открытых скобок в строке не превышает числа <code class="language-plaintext highlighter-rouge">n</code> и если открывающих скобок в строке не меньше закрывающих.</li>
  <li>Закрывающую скобку мы можем добавить, если суммарное количество открытых скобок в строке больше чем закрывающих.</li>
</ul>

<p>В этом решении не нужно постфактум проверять получившиеся скобки на валидность, так что мы сможем отбросить один из множителей в нашей оценке сложности.</p>

<ul id="solution" class="tab" data-tab="b4467218-fd79-4213-8f20-8936a8cd135c" data-name="solution">
  
      <li class="active" id="go">
          <a href="#">go </a>
      </li>
  
      <li id="type-script">
          <a href="#">type script </a>
      </li>
  
</ul>
<ul class="tab-content" id="b4467218-fd79-4213-8f20-8936a8cd135c" data-name="solution">
  
      <li class="active">
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">func</span> <span class="n">generate</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">row</span> <span class="kt">string</span><span class="p">,</span> <span class="n">opened</span> <span class="kt">int</span><span class="p">,</span> <span class="n">closed</span> <span class="kt">int</span><span class="p">,</span> <span class="n">answer</span> <span class="o">*</span><span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="o">*</span><span class="m">2</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">answer</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="n">answer</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="n">opened</span> <span class="o">&gt;=</span> <span class="n">closed</span> <span class="o">&amp;&amp;</span> <span class="n">opened</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">{</span>
		<span class="n">generate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">row</span><span class="o">+</span><span class="s">"("</span><span class="p">,</span> <span class="n">opened</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">closed</span><span class="p">,</span> <span class="n">answer</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="n">opened</span> <span class="o">&gt;</span> <span class="n">closed</span> <span class="p">{</span>
		<span class="n">generate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">row</span><span class="o">+</span><span class="s">")"</span><span class="p">,</span> <span class="n">opened</span><span class="p">,</span> <span class="n">closed</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">answer</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">generateParenthesis</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="n">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
	<span class="n">generate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">"("</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>

</code></pre></div></div>
</li>
  
      <li>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">generate</span> <span class="o">=</span> <span class="p">(</span><span class="nx">n</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">row</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">opened</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">closed</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">answer</span><span class="p">:</span> <span class="kr">string</span><span class="p">[]):</span> <span class="k">void</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">row</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="nx">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">answer</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">row</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">opened</span> <span class="o">&gt;=</span> <span class="nx">closed</span> <span class="o">&amp;&amp;</span> <span class="nx">opened</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">generate</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">row</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">(</span><span class="dl">"</span><span class="p">,</span> <span class="nx">opened</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">closed</span><span class="p">,</span> <span class="nx">answer</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">opened</span> <span class="o">&gt;</span> <span class="nx">closed</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">generate</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">row</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">)</span><span class="dl">"</span><span class="p">,</span> <span class="nx">opened</span><span class="p">,</span> <span class="nx">closed</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">answer</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">generateParenthesis</span> <span class="o">=</span> <span class="p">(</span><span class="nx">n</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">string</span><span class="p">[]</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="na">res</span><span class="p">:</span> <span class="kr">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="nx">generate</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="dl">"</span><span class="s2">(</span><span class="dl">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

</code></pre></div></div>
</li>
  
</ul>

<h3 id="оценка-сложности-1">Оценка сложности</h3>

<p><strong>По времени</strong></p>

<p>В данном решении не нужна валидация последовательности. Ее мы заменили на проверку допустимости добавления открывающей/закрывающей скобки в момент генерации строки. 
Более того, за счет сохранения счетчика суммарного количества открытых и счетчика незакрытых скобок мы можем проводить эту проверку за константное время.</p>

<p>Количество сгенерированных строк равно <code>2<sup>2n-1</sup></code>.</p>

<p>На самом деле количество строк сильно меньше, так как мы заранее отбрасываем все невалидные скобочные последовательности.
Но, оценить их количество сильно сложнее. Валидно будет сказать, что в худшем случае сложность <code>O(2<sup>2n-1</sup>)</code>.</p>

<p><strong>По памяти</strong></p>

<p>Нам нужно выделить память для хранения всех результирующих строк. Каждая строка имеет длину 2*n.
Также, как и в оценке по сложности, валидно сказать, что количество строк сравнимо с <code>2<sup>2n-1</sup></code>.</p>

<p>Таким образом, сложность по памяти равна <code>O(n * 2<sup>2n-1</sup>)</code>.</p>




      <footer class="site-footer">
    <span class="site-footer-owner">
        <a href="https://algorithmics-blog.github.io">Algorithmics</a> is maintained by
        <a href="https://www.linkedin.com/in/avivasyuta/" target="_blank">Aleksei Ivasiuta</a> and
        <a href="https://www.linkedin.com/in/tifongod/" target="_blank">Denis Kolpakov</a>.
    </span>
    <span class="site-footer-credits">
        This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.
    </span>
</footer>


    </section>

    <script src="/assets/js/tabs.js" type="application/javascript"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </body>
</html>
