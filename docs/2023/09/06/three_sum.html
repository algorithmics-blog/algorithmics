<!DOCTYPE html>
<html lang="">

  <head>
  <meta charset="UTF-8">
  <title>Algorithmics</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/assets/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/assets/css/theme.css">
  <link rel="stylesheet" href="/assets/css/tags.css">
  <link rel="stylesheet" href="/assets/css/tabs.css">
  <link rel="icon" type="image/x-icon" href="/assets/favicon.ico">
</head>


  <body>
    <section class="page-header">
    <a href="/">
        <img src="/assets/images/logo.jpg" alt="Algorithmics" class="logo">
    </a>

    <h1 class="project-name">Algorithmics</h1>
    <h2 class="project-tagline"></h2>

    <div>
        <a href="https://github.com/avivasyuta/algorithmics" target="_blank" class="btn">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                <path fill="currentColor" fill-rule="evenodd"
                      d="M11.999 1C5.926 1 1 5.925 1 12c0 4.86 3.152 8.983 7.523 10.437c.55.102.75-.238.75-.53c0-.26-.009-.952-.014-1.87c-3.06.664-3.706-1.475-3.706-1.475c-.5-1.27-1.221-1.61-1.221-1.61c-.999-.681.075-.668.075-.668c1.105.078 1.685 1.134 1.685 1.134c.981 1.68 2.575 1.195 3.202.914c.1-.71.384-1.195.698-1.47c-2.442-.278-5.01-1.222-5.01-5.437c0-1.2.428-2.183 1.132-2.952c-.114-.278-.491-1.397.108-2.91c0 0 .923-.297 3.025 1.127A10.536 10.536 0 0 1 12 6.32a10.49 10.49 0 0 1 2.754.37c2.1-1.424 3.022-1.128 3.022-1.128c.6 1.514.223 2.633.11 2.911c.705.769 1.13 1.751 1.13 2.952c0 4.226-2.572 5.156-5.022 5.428c.395.34.747 1.01.747 2.037c0 1.47-.014 2.657-.014 3.017c0 .295.199.637.756.53C19.851 20.979 23 16.859 23 12c0-6.075-4.926-11-11.001-11"/>
            </svg>
            GitHub
        </a>

        <a href="https://t.me/algorithmics_cl" target="_blank" class="btn">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                <path fill="none" stroke="currentColor" stroke-width="2"
                      d="M22 3L2 11l18.5 8L22 3ZM10 20.5l3-4.5m2.5-6.5L9 14l.859 6.012c.078.546.216.537.306-.003L11 15l4.5-5.5Z"/>
            </svg>
            Telegram
        </a>
    </div>
</section>


    <section class="main-content">

      <a class="back" href="/">
    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 2048 2048">
        <path fill="currentColor"
              d="m1699 249l-775 775l775 775l-241 242L441 1024L1458 7l241 242z"/>
    </svg>
    На главную
</a>

<h1>Сумма трех чисел в массиве</h1>

<p class="meta">
    06 September 2023, Сложность

    

    
    <span class="medium-complexity">Средняя</span>
    

    
    ,

    
    

    <span>
        1 min
    </span>
</p>


<p>
    <a href="https://leetcode.com/problems/3sum" target="_blank">Оригинал задачи на Leetcode</a>
</p>


<h2 id="оглавление">Оглавление</h2>

<ul>
  <li><a href="#описание-задачи">Описание задачи</a></li>
  <li><a href="#ограничения">Ограничения</a></li>
  <li><a href="#примеры">Примеры</a></li>
  <li><a href="#решение-через-hash-set">Решение через Hash Set</a></li>
  <li><a href="#решение-через-два-указателя">Решение через два указателя</a></li>
  <li><a href="#решение-без-сортировки">Решение без сортировки</a></li>
</ul>

<hr />

<h2 id="описание-задачи">Описание задачи</h2>

<p>Дан массив целых чисел <code class="language-plaintext highlighter-rouge">nums</code>.
Напишите функцию, чтобы найти в массиве все уникальные тройки чисел, сумма которых равна нулю.
В одной тройке <code class="language-plaintext highlighter-rouge">[nums[i], nums[j], nums[k]]</code> один и тот же элемент не может повторяться дважды, то есть <code class="language-plaintext highlighter-rouge">i != j, i != k, j != k</code>.</p>

<p>Обратите внимание, что в ответе не должно быть повторяющихся троек. Порядок троек и чисел в тройках не имеет значения.</p>

<hr />

<h2 id="ограничения">Ограничения</h2>

<ul>
  <li>В массиве может быть от 3 до 3000 значений</li>
  <li>В качестве значений могут быть числа в диапазоне от -10<sup>5</sup> до 10<sup>5</sup></li>
</ul>

<hr />

<h2 id="примеры">Примеры</h2>

<ul id="three_sum" class="tab" data-tab="0b3bd3c1-7baf-417e-b257-62b29647a3a2" data-name="three_sum">
  
      <li class="active" id="--------1">
          <a href="#">Пример №1 </a>
      </li>
  
      <li id="--------2">
          <a href="#">Пример №2 </a>
      </li>
  
      <li id="--------3">
          <a href="#">Пример №3 </a>
      </li>
  
</ul>
<ul class="tab-content" id="0b3bd3c1-7baf-417e-b257-62b29647a3a2" data-name="three_sum">
  
      <li class="active">
<p><strong>Входные данные</strong>: <code class="language-plaintext highlighter-rouge">[-1, 0, 1, 2, -1, -4]</code></p>

<p><strong>Ответ</strong>: <code class="language-plaintext highlighter-rouge">[[-1, -1, 2], [-1, 0, 1]]</code></p>
</li>
  
      <li>
<p><strong>Входные данные</strong>: <code class="language-plaintext highlighter-rouge">[0, 0, 0]</code></p>

<p><strong>Ответ</strong>: <code class="language-plaintext highlighter-rouge">[[0, 0, 0]]</code></p>
</li>
  
      <li>
<p><strong>Входные данные</strong>: <code class="language-plaintext highlighter-rouge">[0, 1, 1]</code></p>

<p><strong>Ответ</strong>: <code class="language-plaintext highlighter-rouge">[]</code></p>
</li>
  
</ul>

<hr />

<h2 id="решение-через-hash-set">Решение через Hash Set</h2>

<p>Это решение требует предварительной сортировки массива в возрастающем порядке, поэтому первым делом выполняем сортировку.</p>

<p>Далее мы можем заметить, что задача очень похожа на ее более простой аналог — <a href="/2023/08/30/two_sum.html">Сумма двух чисел в массиве</a>.
Разница только в том, что нам надо найти все тройки, а их сумма всегда равно нулю.
Мы можем воспользоваться подходом из этой задачи и решить ее через дополнительную структуру <code class="language-plaintext highlighter-rouge">HashSet</code> или ее аналоги.</p>

<p>Посмотрим на такой пример ввода <code class="language-plaintext highlighter-rouge">[-1, 0, 1, 2, -1, -4]</code>.</p>

<p>После сортировки мы получим следующий массив <code class="language-plaintext highlighter-rouge">[-4, -1, -1, 0, 1, 2]</code>.</p>

<p>Теперь запускаем цикл по всем элементам массива.</p>

<p>Далее для каждого <code class="language-plaintext highlighter-rouge">i</code>-го элемента мы будем запускать отдельный цикл для поиска недостающей пары чисел из тройки.
Так как мы всегда двигаемся слева направо, то мы можем запускать второй цикл начиная от <code class="language-plaintext highlighter-rouge">i + 1</code> и до конца.</p>

<p>Первое, что нам нужно учесть — это то, что в наших ответах не должно быть одинаковых троек.
Если мы посмотрим еще раз на пример входящих данных, то мы обнаружим что у нас есть два одинаковых возможных решения <code class="language-plaintext highlighter-rouge">[-1, 0, 1]</code>.
В массиве есть две возможные тройки со значениями под индексами <code class="language-plaintext highlighter-rouge">1, 3, 4</code> и <code class="language-plaintext highlighter-rouge">2, 3, 4</code>.
Однако, это легко решить, так как у нас отсортированный массив. Это значит, что одинаковые значения идут подряд и мы просто можем проверять первое и пропускать все остальные.</p>

<p>Добавим проверку в самое начало первого цикла. Если мы перебираем не первый элемент в массиве и текущий элемент равен предыдущему,
то мы просто его пропускаем. И дополнительно создадим <code class="language-plaintext highlighter-rouge">Set</code> для отслеживания уже проверенных чисел.</p>

<p>Теперь у нас есть такая заготовка.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">threeSumHashSet</span> <span class="o">=</span> <span class="p">(</span><span class="nx">nums</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]):</span> <span class="kr">number</span><span class="p">[][]</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// Создаем массив для результатов</span>
    <span class="kd">const</span> <span class="na">result</span><span class="p">:</span> <span class="kr">number</span><span class="p">[][]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1">// Предварительно сортируем массив по возрастанию</span>
    <span class="nx">nums</span><span class="p">.</span><span class="nx">sort</span><span class="p">()</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">firstNum</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>

        <span class="c1">// Не проверяем текущее число, если оно такое же, как и предыдущее, потому для него мы получим такой же результат.</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nx">firstNum</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>

        <span class="kd">const</span> <span class="nx">used</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">()</span>

        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">secondNum</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>

            <span class="c1">// Имплементация</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Осталось решить, что делать внутри второго цикла. А работа внутри него в целом сводится к задаче <a href="/2023/08/30/two_sum.html">Сумма двух чисел в массиве</a>.
Нам нужно вычислить третье число, которого нам не хватает, чтобы получить в сумме ноль и проверить, встречалось ли уже такое число в нашем массиве.
Для проверки мы как раз и используем наш <code class="language-plaintext highlighter-rouge">Set</code>.</p>

<ul>
  <li>Если третье число есть в <code class="language-plaintext highlighter-rouge">used</code>, то мы добавляем в наш результат массив из всех трех полученных чисел.</li>
  <li>Если третьего числа нет в <code class="language-plaintext highlighter-rouge">used</code>, то мы просто записываем в него второе число и идем дальше.</li>
</ul>

<p>Осталось учесть еще один нюанс. Во время перебора второго массива мы тоже можем получать одинаковые значения и тем самым создавать дубликаты.
Поэтому, после добавления найденной тройки нам надо увеличивать <code class="language-plaintext highlighter-rouge">j</code> до тех пор, пока значение под индексом <code class="language-plaintext highlighter-rouge">j</code> равно значению под индексом <code class="language-plaintext highlighter-rouge">j-1</code>.</p>

<p>В результате мы получаем следующие решения задачи.</p>

<ul id="solution" class="tab" data-tab="9bb8bbdc-ae84-4fe4-aacb-815a1557972c" data-name="solution">
  
      <li class="active" id="go">
          <a href="#">go </a>
      </li>
  
      <li id="type-script">
          <a href="#">type script </a>
      </li>
  
</ul>
<ul class="tab-content" id="9bb8bbdc-ae84-4fe4-aacb-815a1557972c" data-name="solution">
  
      <li class="active">
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"sort"</span>

<span class="k">func</span> <span class="n">threeSumHashSet</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="c">// Создаем слайс для результатов</span>
	<span class="n">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>

	<span class="c">// Предварительно сортируем слайс по возрастанию</span>
	<span class="n">sort</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

	<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">firstNum</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">nums</span> <span class="p">{</span>
		<span class="c">// Не проверяем текущее число, если оно такое же, как и предыдущее, потому для него мы получим такой же результат.</span>
		<span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="m">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">firstNum</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="n">indexMap</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>

		<span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="m">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">secondNum</span> <span class="o">:=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

			<span class="c">// Высчитываем третье искомое число</span>
			<span class="n">thirdNum</span> <span class="o">:=</span> <span class="m">0</span> <span class="o">-</span> <span class="n">firstNum</span> <span class="o">-</span> <span class="n">secondNum</span>

			<span class="n">_</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">indexMap</span><span class="p">[</span><span class="n">thirdNum</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">ok</span> <span class="p">{</span>
				<span class="n">result</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="n">firstNum</span><span class="p">,</span> <span class="n">secondNum</span><span class="p">,</span> <span class="n">thirdNum</span><span class="p">})</span>
				<span class="k">for</span> <span class="n">j</span><span class="o">+</span><span class="m">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="m">1</span><span class="p">]</span> <span class="p">{</span>
					<span class="n">j</span><span class="o">++</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">indexMap</span><span class="p">[</span><span class="n">secondNum</span><span class="p">]</span> <span class="o">=</span> <span class="no">true</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>

</code></pre></div></div>
</li>
  
      <li>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">threeSumHashSet</span> <span class="o">=</span> <span class="p">(</span><span class="nx">nums</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]):</span> <span class="kr">number</span><span class="p">[][]</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// Создаем массив для результатов</span>
    <span class="kd">const</span> <span class="na">result</span><span class="p">:</span> <span class="kr">number</span><span class="p">[][]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1">// Предварительно сортируем массив по возрастанию</span>
    <span class="nx">nums</span><span class="p">.</span><span class="nx">sort</span><span class="p">()</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">firstNum</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>

        <span class="c1">// Не проверяем текущее число, если оно такое же, как и предыдущее, потому для него мы получим такой же результат.</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nx">firstNum</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>

        <span class="kd">const</span> <span class="nx">used</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">()</span>

        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">secondNum</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>

            <span class="c1">// Высчитываем третье искомое число</span>
            <span class="kd">const</span> <span class="nx">thirdNum</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="nx">firstNum</span> <span class="o">-</span> <span class="nx">secondNum</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">used</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">thirdNum</span><span class="p">))</span> <span class="p">{</span>
                <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">firstNum</span><span class="p">,</span> <span class="nx">secondNum</span><span class="p">,</span> <span class="nx">thirdNum</span><span class="p">])</span>
                <span class="k">while</span> <span class="p">(</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
                    <span class="nx">j</span><span class="o">++</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nx">used</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">secondNum</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></div></div>
</li>
  
</ul>

<h3 id="оценка-сложности">Оценка сложности</h3>

<p><code class="language-plaintext highlighter-rouge">n</code> - количество элементов в массиве</p>

<p><strong>По времени</strong></p>

<p><code>O(n<sup>2</sup>)</code>, так как мы запускаем цикл в цикле. Дополнительную сложность добавляет сортировка массива, ее сложность равна <code class="language-plaintext highlighter-rouge">O(n * log n)</code>.
Итоговая сложность равна <code class="language-plaintext highlighter-rouge">O(n * log n)</code> + <code>O(n<sup>2</sup>)</code>, что асимптотически эквивалентно <code>O(n<sup>2</sup>)</code>.</p>

<p><strong>По памяти</strong></p>

<p><code class="language-plaintext highlighter-rouge">O(n)</code>, так как мы добавляем в сет <code class="language-plaintext highlighter-rouge">n</code> элементов.</p>

<hr />

<h2 id="решение-через-два-указателя">Решение через два указателя</h2>

<p>Это решение, так же как и предыдущее, требует предварительной сортировки массива.
Поэтому первым делом необходимо отсортировать массив в порядке возрастания.</p>

<p>Теперь мы можем применить подход с двумя указателями, как в задаче <a href="/2023/09/02/two_sum_sorted_array.html">Сумма двух чисел в отсортированном массиве</a>. 
Разница только в том, что нам надо найти все тройки, а их сумма всегда равно нулю.</p>

<p>Посмотрим на такой пример ввода <code class="language-plaintext highlighter-rouge">[-1, 0, 1, 2, -1, -4]</code>.</p>

<p>После сортировки мы получим следующий массив <code class="language-plaintext highlighter-rouge">[-4, -1, -1, 0, 1, 2]</code>.</p>

<p>Теперь запускаем цикл по всем элементам массива.</p>

<p>Далее для каждого <code class="language-plaintext highlighter-rouge">i</code>-го элемента мы будем запускать отдельный цикл для поиска недостающей пары чисел из тройки.
Так как мы всегда двигаемся слева направо, то мы можем запускать второй цикл начиная от <code class="language-plaintext highlighter-rouge">i + 1</code> и до конца.</p>

<p>Как и в предыдущем решении нам надо обеспечить отсутствие дубликатов в ответе, поэтому мы будем проверять одинаковые значения только один раз, а повторения пропускать.</p>

<p>Теперь у нас есть такая заготовка.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">threeSumTwoPointers</span> <span class="o">=</span> <span class="p">(</span><span class="nx">nums</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]):</span> <span class="kr">number</span><span class="p">[][]</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="na">result</span><span class="p">:</span> <span class="kr">number</span><span class="p">[][]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nx">nums</span><span class="p">.</span><span class="nx">sort</span><span class="p">()</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">num</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>

        <span class="c1">// Имплементация</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Теперь мы можем полностью скопировать решение из задачи <a href="/2023/09/02/two_sum_sorted_array.html">Сумма двух чисел в отсортированном массиве</a> и немного его модифицировать.</p>

<ol>
  <li>Заводим два указателя, которые будут хранить индексы. Значение <code class="language-plaintext highlighter-rouge">left</code> делаем равным <code class="language-plaintext highlighter-rouge">i + 1</code>, значение <code class="language-plaintext highlighter-rouge">right</code> равным
индексу последнего элемента.</li>
  <li>Запускаем цикл, который прервется, если <code class="language-plaintext highlighter-rouge">left</code> станет больше или равен <code class="language-plaintext highlighter-rouge">right</code>, то есть когда индексы сойдутся.</li>
  <li>На каждой итерации высчитываем сумму элементов под индексами <code class="language-plaintext highlighter-rouge">left</code>, <code class="language-plaintext highlighter-rouge">right</code>, и <code class="language-plaintext highlighter-rouge">i</code>-го элемента массива и проверяем ее на равенство нулю.</li>
</ol>

<ul>
  <li>Если сумма больше нуля, значит мы сложили слишком большие числа и нам надо взять более маленькие.
Уменьшить сумму мы можем взяв число, которое стоит левее от текущего под индексом <code class="language-plaintext highlighter-rouge">right</code>.
Уменьшаем <code class="language-plaintext highlighter-rouge">right</code> на 1.</li>
  <li>Если сумма меньше нуля, значит мы сложили слишком маленькие числа и нам надо взять более большие.
Увеличить сумму мы можем взяв число, которое стоит правее от текущего под индексом <code class="language-plaintext highlighter-rouge">left</code>.
Увеличиваем <code class="language-plaintext highlighter-rouge">left</code> на 1.</li>
  <li>Если сумма равна нулю, значит мы нашли искомые числа. В таком случае добавляем найденную тройку <code class="language-plaintext highlighter-rouge">[nums[i], nums[left], nums[right]]</code> в коллекцию ответов.
Здесь же сразу уменьшаем <code class="language-plaintext highlighter-rouge">right</code> и увеличиваем <code class="language-plaintext highlighter-rouge">left</code> на единицу, чтобы найти следующую возможную комбинацию.</li>
</ul>

<p>Осталось учесть один нюанс, как и в предыдущем решении. Во время второго перебора мы можем получать одинаковые значения и тем самым создавать дубликаты.
Поэтому, после добавления найденной тройки нам надо увеличивать указатель <code class="language-plaintext highlighter-rouge">left</code> до тех пор, пока значение под индексом <code class="language-plaintext highlighter-rouge">left</code> равно значению под индексом <code class="language-plaintext highlighter-rouge">left - 1</code>.</p>

<ul id="solution" class="tab" data-tab="e2e00f49-f7ef-4707-b3f9-b0f08d6ab053" data-name="solution">
  
      <li class="active" id="go">
          <a href="#">go </a>
      </li>
  
      <li id="type-script">
          <a href="#">type script </a>
      </li>
  
</ul>
<ul class="tab-content" id="e2e00f49-f7ef-4707-b3f9-b0f08d6ab053" data-name="solution">
  
      <li class="active">
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"sort"</span>

<span class="k">func</span> <span class="n">threeSumTwoPointers</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="c">// Создаем слайс для результатов</span>
	<span class="n">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>

	<span class="c">// Предварительно сортируем слайс по возрастанию</span>
	<span class="n">sort</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

	<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">nums</span> <span class="p">{</span>
		<span class="c">// Не проверяем текущее число, если оно такое же, как и предыдущее, потому для него мы получим такой же результат.</span>
		<span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="m">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="n">left</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="m">1</span>
		<span class="n">right</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="m">1</span>

		<span class="k">for</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="p">{</span>
			<span class="n">sum</span> <span class="o">:=</span> <span class="n">num</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>

			<span class="k">if</span> <span class="n">sum</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
				<span class="n">result</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="n">num</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]})</span>
				<span class="n">right</span> <span class="o">-=</span> <span class="m">1</span>
				<span class="n">left</span> <span class="o">+=</span> <span class="m">1</span>

				<span class="k">for</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="o">-</span><span class="m">1</span><span class="p">]</span> <span class="p">{</span>
					<span class="n">left</span> <span class="o">+=</span> <span class="m">1</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
				<span class="n">right</span> <span class="o">-=</span> <span class="m">1</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">left</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="m">1</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>

</code></pre></div></div>
</li>
  
      <li>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">threeSumTwoPointers</span> <span class="o">=</span> <span class="p">(</span><span class="nx">nums</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]):</span> <span class="kr">number</span><span class="p">[][]</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// Создаем массив для результатов</span>
    <span class="kd">const</span> <span class="na">result</span><span class="p">:</span> <span class="kr">number</span><span class="p">[][]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1">// Предварительно сортируем слайс по возрастанию</span>
    <span class="nx">nums</span><span class="p">.</span><span class="nx">sort</span><span class="p">()</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">num</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>

        <span class="c1">// Не проверяем текущее число, если оно такое же, как и предыдущее, потому для него мы получим такой же результат.</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>

        <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="kd">let</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">while</span> <span class="p">(</span><span class="nx">left</span> <span class="o">&lt;</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">num</span> <span class="o">+</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span> <span class="o">+</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">sum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">num</span><span class="p">,</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">left</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">right</span><span class="p">]])</span>
                <span class="nx">right</span><span class="o">--</span>
                <span class="nx">left</span><span class="o">++</span>

                <span class="k">while</span> <span class="p">(</span><span class="nx">left</span> <span class="o">&lt;</span> <span class="nx">right</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span> <span class="o">==</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">left</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
                    <span class="nx">left</span><span class="o">++</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">sum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">right</span><span class="o">--</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">left</span><span class="o">++</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

</code></pre></div></div>
</li>
  
</ul>

<h3 id="оценка-сложности-1">Оценка сложности</h3>

<p><code class="language-plaintext highlighter-rouge">n</code> - количество элементов в массиве</p>

<p><strong>По времени</strong></p>

<p><code>O(n<sup>2</sup>)</code>, так как мы запускаем цикл в цикле. Дополнительную сложность добавляет сортировка массива, ее сложность равна <code class="language-plaintext highlighter-rouge">O(n * log n)</code>.
Итоговая сложность равна <code class="language-plaintext highlighter-rouge">O(n * log n)</code> + <code>O(n<sup>2</sup>)</code>, что асимптотически эквивалентно <code>O(n<sup>2</sup>)</code>.</p>

<p><strong>По памяти</strong></p>

<p>Варьируется от <code class="language-plaintext highlighter-rouge">O(log n)</code> до <code class="language-plaintext highlighter-rouge">O(n)</code> в зависимости от реализации алгоритма сортировки.
На хранение указателей мы тратим константную память <code class="language-plaintext highlighter-rouge">O(1)</code>, поэтому финальная сложность по памяти определяется сложностью алгоритма сортировки.</p>

<hr />

<h2 id="решение-без-сортировки">Решение без сортировки</h2>

<p>Для решения задачи этим способом не требуется предварительная сортировка входного массива чисел.
Для решения можно немного видоизменить <a href="#решение-через-hash-set">реализацию через Hash Set</a>.</p>

<p>Необходимо так же проитерироваться по всем элементам массива и на каждой итерации запустить отдельный цикл от <code class="language-plaintext highlighter-rouge">i + 1</code>.
Для того чтобы не проверять повторяющиеся числа, мы будем записывать каждое в структуру Hash Set <code class="language-plaintext highlighter-rouge">dups</code> и в начале итерации проверять, если уже такой элемент.
Если в Hash Set уже есть такое число, то мы просто пропускаем итерацию.</p>

<p>Также необходимо определить Hash Map <code class="language-plaintext highlighter-rouge">seen</code>, в которую мы будем записывать уже проверенные пары двоек <code class="language-plaintext highlighter-rouge">firstNum</code> и <code class="language-plaintext highlighter-rouge">secondNum</code>.
При таком подходе мы можем вычислять на каждой итерации второго цикла недостающее число <code class="language-plaintext highlighter-rouge">thirdNum</code> и проверять есть ли уже такая пара в <code class="language-plaintext highlighter-rouge">seen</code>.
Если такая пара есть, то мы нашли искомую тройку.</p>

<p>Теперь нам нужно избежать добавления одинаковых троек в ответ.
Для этого можно воспользоваться хитрым приемом, но он работает не во всех языках.</p>

<p>В таких языках, как <code class="language-plaintext highlighter-rouge">Python</code> и <code class="language-plaintext highlighter-rouge">Java</code> мы можем создать массив (лист) из трех элементов, отсортировать их в любом порядке и добавить в еще один Has Set <code class="language-plaintext highlighter-rouge">uniq</code>.
Добавление отсортированных троек обеспечит автоматическое избавление от дублей благодаря механике Hash Set.
В конце просто нужно конвертировать Hash Set в массив и вернуть в качестве ответа.</p>

<p>Однако, в таких языках как, например, <code class="language-plaintext highlighter-rouge">Go</code>, <code class="language-plaintext highlighter-rouge">JavaScript</code> и <code class="language-plaintext highlighter-rouge">TypeScript</code> провернуть такое не получится.
В <code class="language-plaintext highlighter-rouge">Go</code> нельзя использовать слайсы в качестве ключей, потому что это не сравниваемые типы.
В <code class="language-plaintext highlighter-rouge">JavaScript</code> и <code class="language-plaintext highlighter-rouge">TypeScript</code> массивы использовать можно, но они передаются по ссылке, поэтому в Hash Set можно спокойно добавить одинаковые массивы, так как у них разные ссылки.</p>

<p>В этих языках в качестве ключа придется использовать строку вида <code class="language-plaintext highlighter-rouge">1.2.3</code>, где через точку записаны три числа из тройки в отсортированном порядке.
Таким образом мы создадим уникальный ключ и избежим дубликатов при добавлении.
Однако, при возврате результата нам придется обратно разобрать каждую строку на отдельные числа с приведением типов.</p>

<ul id="solution" class="tab" data-tab="f4f161e2-74be-4576-9a84-b7fc8516ef2d" data-name="solution">
  
      <li class="active" id="go">
          <a href="#">go </a>
      </li>
  
      <li id="type-script">
          <a href="#">type script </a>
      </li>
  
</ul>
<ul class="tab-content" id="f4f161e2-74be-4576-9a84-b7fc8516ef2d" data-name="solution">
  
      <li class="active">
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"sort"</span>
	<span class="s">"strconv"</span>
	<span class="s">"strings"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">threeSumNoSort</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="n">uniq</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
	<span class="n">dups</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
	<span class="n">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>

	<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">firstNum</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">nums</span> <span class="p">{</span>
		<span class="n">_</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">dups</span><span class="p">[</span><span class="n">firstNum</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">ok</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="n">dups</span><span class="p">[</span><span class="n">firstNum</span><span class="p">]</span> <span class="o">=</span> <span class="no">true</span>

		<span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="m">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">secondNum</span> <span class="o">:=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

			<span class="c">// Высчитываем третье искомое число</span>
			<span class="n">thirdNum</span> <span class="o">:=</span> <span class="m">0</span> <span class="o">-</span> <span class="n">firstNum</span> <span class="o">-</span> <span class="n">secondNum</span>

			<span class="n">idx</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">seen</span><span class="p">[</span><span class="n">thirdNum</span><span class="p">]</span>

			<span class="k">if</span> <span class="n">ok</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">i</span> <span class="p">{</span>
				<span class="c">// Собираем уникальную тройку</span>
				<span class="n">triplet</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="n">strconv</span><span class="o">.</span><span class="n">Itoa</span><span class="p">(</span><span class="n">firstNum</span><span class="p">),</span> <span class="n">strconv</span><span class="o">.</span><span class="n">Itoa</span><span class="p">(</span><span class="n">secondNum</span><span class="p">),</span> <span class="n">strconv</span><span class="o">.</span><span class="n">Itoa</span><span class="p">(</span><span class="n">thirdNum</span><span class="p">)}</span>

				<span class="c">// Сортируем тройку, чтобы избежать дублей</span>
				<span class="n">sort</span><span class="o">.</span><span class="n">Strings</span><span class="p">(</span><span class="n">triplet</span><span class="p">)</span>

				<span class="c">// Конвертируем тройку в строку и добавляем в map</span>
				<span class="n">str</span> <span class="o">:=</span> <span class="n">strings</span><span class="o">.</span><span class="n">Join</span><span class="p">(</span><span class="n">triplet</span><span class="p">,</span> <span class="s">"."</span><span class="p">)</span>
				<span class="n">uniq</span><span class="p">[</span><span class="n">str</span><span class="p">]</span> <span class="o">=</span> <span class="no">true</span>
			<span class="p">}</span>

			<span class="n">seen</span><span class="p">[</span><span class="n">secondNum</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c">// Разбираем map с уникальными ключами обратно в слайс троек</span>
	<span class="n">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniq</span><span class="p">))</span>

	<span class="k">for</span> <span class="n">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">uniq</span> <span class="p">{</span>
		<span class="n">numStrs</span> <span class="o">:=</span> <span class="n">strings</span><span class="o">.</span><span class="n">Split</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">"."</span><span class="p">)</span>
		<span class="n">resNums</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">numStrs</span><span class="p">))</span>

		<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">numStr</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">numStrs</span> <span class="p">{</span>
			<span class="n">num</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">strconv</span><span class="o">.</span><span class="n">Atoi</span><span class="p">(</span><span class="n">numStr</span><span class="p">)</span>
			<span class="n">resNums</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">resNums</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="n">res</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">resNums</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>

</code></pre></div></div>
</li>
  
      <li>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">threeSumNoSort</span> <span class="o">=</span> <span class="p">(</span><span class="nx">nums</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]):</span> <span class="kr">number</span><span class="p">[][]</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">uniq</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="kd">const</span> <span class="nx">dups</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="kd">const</span> <span class="nx">seen</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="kr">number</span><span class="p">,</span> <span class="kr">number</span><span class="o">&gt;</span><span class="p">()</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">firstNum</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">dups</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">firstNum</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>

        <span class="nx">dups</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">firstNum</span><span class="p">)</span>

        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">secondNum</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>

            <span class="c1">// Высчитываем третье искомое число</span>
            <span class="kd">const</span> <span class="nx">thirdNum</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="nx">firstNum</span> <span class="o">-</span> <span class="nx">secondNum</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">seen</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">thirdNum</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">seen</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">thirdNum</span><span class="p">)</span> <span class="o">===</span> <span class="nx">firstNum</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Собираем уникальную тройку</span>
                <span class="kd">const</span> <span class="nx">triplet</span> <span class="o">=</span> <span class="p">[</span><span class="nx">firstNum</span><span class="p">,</span> <span class="nx">secondNum</span><span class="p">,</span> <span class="nx">thirdNum</span><span class="p">]</span>

                <span class="c1">// Сортируем тройку, чтобы избежать дублей</span>
                <span class="nx">triplet</span><span class="p">.</span><span class="nx">sort</span><span class="p">()</span>

                <span class="c1">// Конвертируем тройку в строку и добавляем в set</span>
                <span class="nx">uniq</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">triplet</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">'</span><span class="s1">.</span><span class="dl">'</span><span class="p">))</span>
            <span class="p">}</span>

            <span class="nx">seen</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">secondNum</span><span class="p">,</span> <span class="nx">firstNum</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Конвертируем set строк в массив</span>
    <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">uniq</span><span class="p">).</span><span class="nx">reduce</span><span class="o">&lt;</span><span class="kr">number</span><span class="p">[][]</span><span class="o">&gt;</span><span class="p">((</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">tripletStr</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">tripletArr</span> <span class="o">=</span> <span class="nx">tripletStr</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">.</span><span class="dl">'</span><span class="p">)</span>
        <span class="kd">const</span> <span class="nx">triplet</span> <span class="o">=</span> <span class="nx">tripletArr</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">numStr</span> <span class="o">=&gt;</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">numStr</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[...</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">triplet</span><span class="p">]</span>
    <span class="p">},</span> <span class="p">[])</span>
<span class="p">}</span>
</code></pre></div></div>
</li>
  
</ul>

<h3 id="оценка-сложности-2">Оценка сложности</h3>

<p><code class="language-plaintext highlighter-rouge">n</code> - количество элементов в массиве</p>

<p><strong>По времени</strong></p>

<p><code>O(n<sup>2</sup>)</code> так как мы запускаем цикл в цикле.</p>

<p>Хотя асимптотическая сложность такая же, как в предыдущих решениях, этот алгоритм заметно медленнее.
Поиск в хеш-наборе, хотя и требует постоянного времени, является дорогостоящим по сравнению с прямым доступом к памяти.</p>

<p><strong>По памяти</strong></p>

<p><code class="language-plaintext highlighter-rouge">O(n)</code> так как мы заводим дополнительные структуры для хранения чисел, которые зависят от длины входного массива.</p>





      <footer class="site-footer">
    <span class="site-footer-owner">
        <a href="https://algorithmics-blog.github.io">Algorithmics</a> is maintained by
        <a href="https://www.linkedin.com/in/avivasyuta/" target="_blank">Aleksei Ivasiuta</a> and
        <a href="https://www.linkedin.com/in/tifongod/" target="_blank">Denis Kolpakov</a>.
    </span>
    <span class="site-footer-credits">
        This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.
    </span>
</footer>


    </section>

    <script src="/assets/js/tabs.js" type="application/javascript"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </body>
</html>
