# Контейнер с наибольшим количеством воды

[leetcode](https://leetcode.com/problems/container-with-most-water/)

Сложность: Средняя

## Оглавление

- [Описание](#description)
- [Решение через брутфорс 1](#bruteforce_1)
- [Решение через брутфорс 2](#bruteforce_2)
- [Решение через скользящее окно](#sliding_window)

---

## <a name="description"></a>Описание

Вам дан целочисленный массив высот `height` длиною `n`.

Найдите две линии, которые вместе с осью X образуют контейнер, в котором содержится больше всего воды.
Верните из функции максимальное количество воды, которое может хранить контейнер.

Задача сводится к поиску прямоугольника максимальной площади.

### Ограничения

- В массиве всегда есть минимум 2 элемента
- Значений элементов может быть в диапазоне от 0 до 104

### Примеры

#### Пример #1

```
Вход: [1,8,6,2,5,4,8,3,7]
```

```
Ответ: 49
```

Максимальная площадь прямоугольника при выборе второй и последней высот в массиве (8, 7).
Тогда высота квадрата — 7 и длина — 7 (индексы «высот» 8 и 1, разница индексов — 7)

#### Пример #2

```
Вход: [1,1]
```

```
Ответ: 1
```

С массивом из 2-х элементов возможен только один возможный прямоугольник `min(a[0], a[1]) * (1 - 0)`

### <a name="bruteforce_1"></a>Решение через брутфорс 1

Задачу можно разделить на 2 этапа:
- поиск всех возможных площадей всех возможных прямоугольников с сохранением результатов в промежуточный массив;
- поиск максимума в массиве.

Вычисление всех возможных площадей прямоугольников:
```go
squares := make([]int, 0, len(height)*len(height))
for i := 0; i < len(height)-1; i++ {
    for j := i + 1; j < len(height); j++ {
        minHeight := height[i]
        if height[j] < minHeight {
            minHeight = height[j]
        }

        squares = append(squares, minHeight*(j-i))
    }
}
```

Поиск максимума:
```go
res := 0
for _, square := range squares {
    if square > res {
        res = square
    }
}
```

#### Оценка сложности

**По времени** 

Для того чтобы вычислить все возможные площади, необходимо перебрать все возможные комбинации 2-х элементов в массиве.
Это сводится к «циклу в цикле», что можно прировнять к сложности <code>O(n<sup>2</sup>)</code>

Для того чтобы найти максимум в массиве, нужно перебрать весь получившийся массив один раз.
Так как массив `squares` имеет размер ~n<sup>2</sup>, то сложность также сводится к <code>O(n<sup>2</sup>)</code>.

То есть суммарная оценка <code>O(n<sup>2</sup>)</code> + <code>O(n<sup>2</sup>)</code> = <code>O(2n<sup>2</sup>)</code>

Так как при оценке алгоритма нам важен только порядок роста функции (т.е. приниматься будет только
главный член формулы, отбросив все константные множители), итоговая оценка - <code>O(n<sup>2</sup>)</code>

**По памяти**

Для хранения всех площадей нам потребовался дополнительный массив `squares`, чей размер сравним с <code>n<sup>2</sup></code>.

#### Небольшие улучшения

Можно заметить, что для вычисления максимумов нам нет нужды сохранять площади в промежуточный массив,
мы можем проверять сравнивать и сохранять максимальную площадь в момент расчета:

```go
func maxArea(height []int) int {
  res := 0
  for i := 0; i < len(height)-1; i++ {
      for j := i + 1; j < len(height); j++ {
          minHeight := height[i]
          if height[j] < minHeight {
              minHeight = height[j]
          }
          
          square := minHeight*(j-i)
          if square > res {
              res = square
          }
      }
  }

  return res
}
```

Таким образом мы избавляемся от необходимости хранить дополнительный массив `squares` размером <code>n<sup>2</sup></code> и отдельно вычислять
максимумы в этом массиве.

Итоговая оценка: <code>n<sup>2</sup></code> по сложности и константная дополнительная память.

P.S. Несмотря на то, что мы избавились от дополнительного обхода массива squares, на итоговую сложность алгоритма
это не повлияло, так в оценке нам важен порядок роста, который остался прежним, так как мы все еще обходим
входящий массив «циклом в цикле».


### <a name="bruteforce_2"></a>Решение через брутфорс 2

Если попробовать отправить первое решение, leetcode не примет его, так как оно отрабатывает слишком долго 
и не укладывается в timeout.

Можно попробовать его немного улучшить, отбросив заведомо лишние действия. 
Для этого вложенный цикл запустим не от следующего за `i` элемента, а от максимально далекого.
Таким образом мы сперва проверяем прямоугольники с максимальной длиной.
В этом случае мы сможем добавить условие выхода из внутреннего цикла
(не уменьшать дальше длины прямоугольника, так как все прямоугольники с меньшей длинной при заданном i окажутся заведомо меньшей площади):
```go
length := j - i
if length*height[i] < res {
    break
}
```

В итоге мы получим следующий брутфорс вариант, который уже сможет пройти проверку на leetcode:
```go
func maxArea(height []int) int {
	res := 0
	for i := 0; i < len(height)-1; i++ {
		for j := len(height) - 1; j > i; j-- {
			length := j - i
			if length*height[i] < res {
				break
			}

			minHeight := height[i]
			if height[j] < minHeight {
				minHeight = height[j]
			}

			square := minHeight * length
			if square > res {
				res = square
			}
		}
	}

	return res
}
```

### <a name="sliding_window"></a> Скользящее окно

#### Описание алгоритма

Для решения подобных задач оптимальным подходом может оказаться «скользящее окно».
Идея состоит в том, чтобы выбрать некое окно и в зависимости от условий сдвигать одну или обе границы окна в сторону.

В нашем случае в качестве первоначального «окна» мы можем взять весь массив.
Так же как и в [улучшенном брутфорсе](#bruteforce_2) начинаем с прямоугольника максимальной длины.
Окно мы будем сужать, пока не дойдем до единичного отрезка в длину.
Так как в качестве первоначального окна мы берем прямоугольник с максимальной длиной, 
то единственный способ получить прямоугольник большей площади при уменьшении длины — увеличение высоты.


Таким образом, нам нужно сужать прямоугольник со стороны меньшей из высот, чтобы увеличить минимальную высоту «аквариума».
На каждой итерации считаем площадь нового прямоугольника и сравниваем с максимумом.
В случае, если и левая и правая сторона «аквариума» одинаковы — «сужаем» окно с обоих направлений.

```go
func maxArea(height []int) int {
	res := 0
	i := 0
	j := len(height) - 1

	for i < j {
		length := j - i
		minHeight := height[i]
		if height[j] < minHeight {
			minHeight = height[j]
		}

		square := length * minHeight
		if square > res {
			res = square
		}

		if height[i] < height[j] {
			i++
			continue
		}

		if height[j] < height[i] {
			j--
			continue
		}

		i++
		j--
	}

	return res
}
```

#### Оценка сложности

**По времени**

На каждой итерации мы двигаем либо правую, либо левую границу окна. Таким образом, суммарно мы подвинем границу `O(n - 1)` раз. 
Это единственная переменная величина. Таким образом, алгоритм имеет линейный порядок роста `O(n)`.

**По памяти**

Мы никак не преобразуем входящие данные и не храним промежуточные результаты (как в случае с [брутфорсом](#bruteforce_1)).
Сложность по памяти константная — `O(1)`.