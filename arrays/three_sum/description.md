# Сумма трех чисел в массиве

[leetcode](https://leetcode.com/problems/3sum/)

Сложность: Средняя

## Оглавление

- [Описание задачи](#description)
- [Решение через Hash Set](#hash_set)
- [Решение через два указателя](#two_pointers)

---

## <a name="description"></a>Описание

Дан массив целых чисел `nums`.
Напишите функцию, чтобы найти в массиве все уникальные тройки чисел, сумма которых равна нулю.
В одной тройке `[nums[i], nums[j], nums[k]]` один и тот же элемент не может повторяться дважды, то есть `i != j, i != k, j != k`.

Обратите внимание, что в ответе не должно быть повторяющихся троек. Порядок троек и чисел в тройках не имеет значения.

### Ограничения

- В массиве может быть от 3 до 3000 значений
- В качестве значений могут быть числа в диапазоне от -10^5 до 10^5

### Примеры

### Пример 1

```
Вход:  nums = [-1, 0, 1, 2, -1, -4]
```

```
Ответ: [[-1, -1, 2], [-1, 0, 1]]
```

#### Пример 2

```
Вход:  nums = [0, 1, 1]
```

```
Ответ: []
```

#### Пример 3

```
Вход:  nums = [0, 0, 0]
```

```
Ответ: [[0, 0, 0]]
```

## <a name="hash_set"></a>Решение через Hash Set

Это решение требует предварительной сортировки массива в возрастающем порядке, поэтому первым делом выполняем сортировку.

Далее мы можем заметить, что задача очень похожа на ее более простой аналог — [Сумма двух чисел в массиве](../two_sum/description.md).
Разница только в том, что нам надо найти все тройки, а их сумма всегда равно нулю.
Мы можем воспользоваться подходом из этой задачи и решить ее через дополнительную структуру `HashSet` или ее аналоги.

Посмотрим на такой пример ввода `[-1, 0, 1, 2, -1, -4]`. После сортировки мы получим следующий массив `[-4, -1, -1, 0, 1, 2]`.

Теперь запускаем цикл по всем элементам массива.

Далее для каждого `i`-го элемента мы будем запускать отдельный цикл для поиска недостающей пары чисел из тройки.
Так как мы всегда двигаемся слева направо, то мы можем запускать второй цикл начиная от `i + 1` и до конца.

Первое, что нам нужно учесть — это то, что в наших ответах не должно быть одинаковых троек.
Если мы посмотрим еще раз на пример входящих данных, то мы обнаружим что у нас есть два одинаковых возможных решения `[-1, 0, 1]`.
В массиве есть две возможные тройки со значениями под индексами `1, 3, 4` и `2, 3, 4`.
Однако, это легко решить, так как у нас отсортированный массив. Это значит, что одинаковые значения идут подряд и мы просто можем проверять первое и пропускать все остальные.

Добавим проверку в самое начало первого цикла. Если мы перебираем не первый элемент в массиве и текущий элемент равен предыдущему,
то мы просто его пропускаем. И дополнительно создадим `Set` для отслеживания уже проверенных чисел.

Теперь у нас есть такая заготовка.

```typescript
export const threeSumHashSet = (nums: number[]): number[][] => {
    // Создаем массив для результатов
    const result: number[][] = []

    // Предварительно сортируем массив по возрастанию
    nums.sort()

    for (let i = 0; i < nums.length; i++) {
        const firstNum = nums[i]

        // Не проверяем текущее число, если оно такое же, как и предыдущее, потому для него мы получим такой же результат.
        if (i != 0 && nums[i - 1] == firstNum) {
            continue
        }

        const used = new Set<number>()

        for (let j = i + 1; j < nums.length; j++) {
            const secondNum = nums[j]
        }
    }

    return result
}
```

Осталось решить, что делать внутри второго цикла. А работа внутри него в целом сводится к задаче [Сумма двух чисел в массиве](../two_sum/description.md).
Нам нужно вычислить третье число, которого нам не хватает, чтобы получить в сумме ноль и проверить, встречалось ли уже такое число в нашем массиве.
Для проверки мы как раз и используем наш `Set`. 

- Если третье число есть в `used`, то мы добавляем в наш результат массив из всех трех полученных чисел.
- Если третьего числа нет в `used`, то мы просто записываем в него второе число и идем дальше.

Осталось учесть еще один нюанс. Во время перебора второго массива мы тоже можем получать одинаковые значения и тем самым создавать дубликаты.
Поэтому, после добавления найденной тройки нам надо увеличивать `j` до тех пор, пока значение под индексом `j` равно значению под индексом `j-1`.

В результате мы получаем следующие решения задачи.

[Решение на GO](./go/solution_hash_set.go)

[Решение на TypeScript](./ts/solution_hash_set.ts)

## Оценка сложности

`n` - количество элементов в массиве

- Сложность по времени `O(n^2)`, так как мы запускаем цикл в цикле. Дополнительную сложность добавляет сортировка массива, ее сложность равна `O(nlogn)`.
Итоговая сложность равна `O(nlogn + n^2)`, что асимптотически эквивалентно `O(n^2)`.

- Сложность по памяти `O(n)`, так как мы добавляем в сет `n` элементов.


## <a name="two_pointers"></a>Решение через два указателя



[Решение на GO](./go/solution_two_pointers.go)

[Решение на TypeScript](./ts/solution_two_pointers.ts)

## Оценка сложности

`n` - количество элементов в массиве

- Сложность по времени `O(n)`, так как мы итерируемся по всем элементам массива.
- Сложность по памяти `O(n)`, так как мы добавляем в мапу `n` элементов.