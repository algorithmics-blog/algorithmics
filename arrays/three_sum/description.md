# Сумма трех чисел в массиве

[leetcode](https://leetcode.com/problems/3sum/)

Сложность: Средняя

## Оглавление

- [Описание задачи](#description)
- [Решение через Hash Set](#hash_set)
- [Решение через два указателя](#two_pointers)

---

## <a name="description"></a>Описание

Дан массив целых чисел `nums`.
Напишите функцию, чтобы найти в массиве все уникальные тройки чисел, сумма которых равна нулю.
В одной тройке `[nums[i], nums[j], nums[k]]` один и тот же элемент не может повторяться дважды, то есть `i != j, i != k, j != k`.

Обратите внимание, что в ответе не должно быть повторяющихся троек. Порядок троек и чисел в тройках не имеет значения.

### Ограничения

- В массиве может быть от 3 до 3000 значений
- В качестве значений могут быть числа в диапазоне от -10^5 до 10^5

### Примеры

### Пример 1

```
Вход:  nums = [-1, 0, 1, 2, -1, -4]
```

```
Ответ: [[-1, -1, 2], [-1, 0, 1]]
```

#### Пример 2

```
Вход:  nums = [0, 1, 1]
```

```
Ответ: []
```

#### Пример 3

```
Вход:  nums = [0, 0, 0]
```

```
Ответ: [[0, 0, 0]]
```

## <a name="hash_set"></a>Решение через Hash Set

Это решение требует предварительной сортировки массива в возрастающем порядке, поэтому первым делом выполняем сортировку.

Далее мы можем заметить, что задача очень похожа на ее более простой аналог — [Сумма двух чисел в массиве](../two_sum/description.md).
Разница только в том, что нам надо найти все тройки, а их сумма всегда равно нулю.
Мы можем воспользоваться подходом из этой задачи и решить ее через дополнительную структуру `HashSet` или ее аналоги.

Посмотрим на такой пример ввода `[-1, 0, 1, 2, -1, -4]`. После сортировки мы получим следующий массив `[-4, -1, -1, 0, 1, 2]`.

Теперь запускаем цикл по всем элементам массива.

Далее для каждого `i`-го элемента мы будем запускать отдельный цикл для поиска недостающей пары чисел из тройки.
Так как мы всегда двигаемся слева направо, то мы можем запускать второй цикл начиная от `i + 1` и до конца.

Первое, что нам нужно учесть — это то, что в наших ответах не должно быть одинаковых троек.
Если мы посмотрим еще раз на пример входящих данных, то мы обнаружим что у нас есть два одинаковых возможных решения `[-1, 0, 1]`.
В массиве есть две возможные тройки со значениями под индексами `1, 3, 4` и `2, 3, 4`.
Однако, это легко решить, так как у нас отсортированный массив. Это значит, что одинаковые значения идут подряд и мы просто можем проверять первое и пропускать все остальные.

Добавим проверку в самое начало первого цикла. Если мы перебираем не первый элемент в массиве и текущий элемент равен предыдущему,
то мы просто его пропускаем. И дополнительно создадим `Set` для отслеживания уже проверенных чисел.

Теперь у нас есть такая заготовка.

> [!NOTE]  
> Пример приведен на языке TypeScript

```typescript
export const threeSumHashSet = (nums: number[]): number[][] => {
    // Создаем массив для результатов
    const result: number[][] = []

    // Предварительно сортируем массив по возрастанию
    nums.sort()

    for (let i = 0; i < nums.length; i++) {
        const firstNum = nums[i]

        // Не проверяем текущее число, если оно такое же, как и предыдущее, потому для него мы получим такой же результат.
        if (i != 0 && nums[i - 1] == firstNum) {
            continue
        }

        const used = new Set<number>()

        for (let j = i + 1; j < nums.length; j++) {
            const secondNum = nums[j]

            // Имплементация
        }
    }

    return result
}
```

Осталось решить, что делать внутри второго цикла. А работа внутри него в целом сводится к задаче [Сумма двух чисел в массиве](../two_sum/description.md).
Нам нужно вычислить третье число, которого нам не хватает, чтобы получить в сумме ноль и проверить, встречалось ли уже такое число в нашем массиве.
Для проверки мы как раз и используем наш `Set`. 

- Если третье число есть в `used`, то мы добавляем в наш результат массив из всех трех полученных чисел.
- Если третьего числа нет в `used`, то мы просто записываем в него второе число и идем дальше.

Осталось учесть еще один нюанс. Во время перебора второго массива мы тоже можем получать одинаковые значения и тем самым создавать дубликаты.
Поэтому, после добавления найденной тройки нам надо увеличивать `j` до тех пор, пока значение под индексом `j` равно значению под индексом `j-1`.

В результате мы получаем следующие решения задачи.

[Решение на GO](./go/solution_hash_set.go)

[Решение на TypeScript](./ts/solution_hash_set.ts)

## Оценка сложности

`n` - количество элементов в массиве

- Сложность по времени `O(n^2)`, так как мы запускаем цикл в цикле. Дополнительную сложность добавляет сортировка массива, ее сложность равна `O(nlogn)`.
Итоговая сложность равна `O(nlogn + n^2)`, что асимптотически эквивалентно `O(n^2)`.

- Сложность по памяти `O(n)`, так как мы добавляем в сет `n` элементов.


## <a name="two_pointers"></a>Решение через два указателя

Это решение, так же как и предыдущее, требует предварительной сортировки массива.
Поэтому первым делом необходимо отсортировать массив в порядке возрастания.

Теперь мы можем применить подход с двумя указателями, как в задаче [Сумма двух чисел в отсортированном массиве](../two_sum_sorted_array/description.md). 
Разница только в том, что нам надо найти все тройки, а их сумма всегда равно нулю.

Посмотрим на такой пример ввода `[-1, 0, 1, 2, -1, -4]`. После сортировки мы получим следующий массив `[-4, -1, -1, 0, 1, 2]`.

Теперь запускаем цикл по всем элементам массива.

Далее для каждого `i`-го элемента мы будем запускать отдельный цикл для поиска недостающей пары чисел из тройки.
Так как мы всегда двигаемся слева направо, то мы можем запускать второй цикл начиная от `i + 1` и до конца.

Как и в предыдущем решении нам надо обеспечить отсутствие дубликатов в ответе, поэтому мы будем проверять одинаковые значения только один раз, а повторения пропускать.

Теперь у нас есть такая заготовка.

> [!NOTE]  
> Пример приведен на языке TypeScript
> 
```typescript
export const threeSumTwoPointers = (nums: number[]): number[][] => {
    const result: number[][] = []

    nums.sort()

    for (let i = 0; i < nums.length; i++) {
        const num = nums[i]

        if (i != 0 && nums[i-1] == num) {
            continue
        }

        // Имплементация
    }

    return result
}
```

Теперь мы можем полностью скопировать решение из задачи [Сумма двух чисел в отсортированном массиве](../two_sum_sorted_array/description.md) и немного его модифицировать.

1. Заводим два указателя, которые будут хранить индексы. Значение `left` делаем равным `i + 1`, значение `right` равным
   индексу последнего элемента.
2. Запускаем цикл, который прервется, если `left` станет больше или равен `right`, то есть когда индексы сойдутся.
3. На каждой итерации высчитываем сумму элементов под индексами `left`, `right`, и `i`-го элемента массива и проверяем ее на равенство нулю.

- Если сумма больше нуля, значит мы сложили слишком большие числа и нам надо взять более маленькие.
  Уменьшить сумму мы можем взяв число, которое стоит левее от текущего под индексом `right`.
  Уменьшаем `right` на 1.
- Если сумма меньше нуля, значит мы сложили слишком маленькие числа и нам надо взять более большие.
  Увеличить сумму мы можем взяв число, которое стоит правее от текущего под индексом `left`.
  Увеличиваем `left` на 1.
- Если сумма равна нулю, значит мы нашли искомые числа. В таком случае добавляем найденную тройку `[nums[i], nums[left], nums[right]]` в коллекцию ответов.
Здесь же сразу уменьшаем `right` и увеличиваем `left` на единицу, чтобы найти следующую возможную комбинацию.

Осталось учесть один нюанс, как и в предыдущем решении. Во время второго перебора мы можем получать одинаковые значения и тем самым создавать дубликаты.
Поэтому, после добавления найденной тройки нам надо увеличивать указатель `left` до тех пор, пока значение под индексом `left` равно значению под индексом `left - 1`.

[Решение на GO](./go/solution_two_pointers.go)

[Решение на TypeScript](./ts/solution_two_pointers.ts)

## Оценка сложности

`n` - количество элементов в массиве

- Сложность по времени `O(n^2)`, так как мы запускаем цикл в цикле. Дополнительную сложность добавляет сортировка массива, ее сложность равна `O(nlogn)`.
  Итоговая сложность равна `O(nlogn + n^2)`, что асимптотически эквивалентно `O(n^2)`.

- Сложность по памяти варьируется от `O(logn)` до `O(n)` в зависимости от реализации алгоритма сортировки.
На хранение указателей мы тратим константную память `O(1)`, поэтому финальная сложность по памяти определяется сложностью алгоритма сортировки.