# Игра в грабителя

[leetcode](https://leetcode.com/problems/house-robber/description/)

Сложность: Средняя

## Оглавление

- [Описание](#description)
- [Брутфорс решение](#solution_1)
- [Оптимальное решение](#solution_2)

---

## <a name="description"></a>Описание

Вы профессиональный грабитель, планирующий грабить дома на улице.
В каждом доме спрятана определенная сумма денег.
Единственное ограничение, которое мешает вам ограбить каждый из них, это то, что в соседних домах подключены системы безопасности, и они автоматически свяжутся с полицией, если в одну ночь взломали два соседних дома.

Вам дан массив чисел, представляющий сумму денег в каждом доме. 
Верните максимальную сумму денег, которую вы можете украсть сегодня вечером, не предупредив полицию.

Входные данные: []int (сумма, которую грабитель может украсть в соответствующем доме)

Выходные данные: int (максимальная сумма грабежа)

### Ограничения

- Количество домов (длина массива) - от 1 до 100
- 0 <= nums[i] <= 400

### Примеры

#### Пример 1

```
Вход: [1,2,3,1]
```

```
Ответ: 4
```

Оптимальное решение — первый и третий дом.

#### Пример 2

```
Вход: [2,7,9,3,1]
```

```
Ответ: 12
```

Оптимальное решение — первый, третий и пятый дом.

#### Пример 3

```
Вход: [1]
```

```
Ответ: 1
```

Так как дом всего один — он и есть оптимальное решение.

#### Пример 4

```
Вход: [2, 1]
```

```
Ответ: 2
```

Оптимальное решение — первый дом.

#### Пример 5

```
Вход: [100, 9, 10, 9, 1, 100]
```

```
Ответ: 210
```

Оптимальное решение — первый, третий и шестой дом. 
Этот пример важен, потому что в процессе ограбления выгоднее всего после третьего дома пропустить не один, а сразу два дома (т.е. перейти с нечетных домов, на четные).

## <a name="solution_1"></a> Брутфорс решение

Первое, что может прийти в голову, сгенерить и посчитать все возможные комбинации. 
Такое решение будет обладать достаточно большой сложностью, так как после каждого дома у грабителя будет возможность пойти по двум маршрутам: через один и через два дома.
Не будем задерживаться на этом подходе, так как оптимальное решение и проще реализовать и она существенно быстрее.

Но, так как подобное решение самое очевидное на старте, оставлю ссылку на реализацию:

- [Решение на GO](./go/bruteforce.go)
- [Решение на TS](./ts/bruteforce.ts)

### Оценка сложности

**По времени**

Длина любой последовательности не может превышать n/2. После каждого дома возможно разветвление маршрута на 2 - пойти либо в дом через один, либо через два.
Таким образом, общее кол-во маршрутов можно оценить как <code>2<sup>n/2</sup></code>.

Так как для нахождения максимума нам нужно пройтись по каждому из этих маршрутов, итоговую оценку сложности можно также оценить в <code>2<sup>n/2</sup></code>.

**По памяти**

<code>(n/2)*2<sup>n/2</sup></code> — дополнительная память для того, чтобы сохранить все возможные маршруты.

## <a name="solution_2"></a> Оптимальное решение

Это еще одна задача, которую можно реализовать, используя подход динамического программирования.
Грабитель может закончить либо на последнем доме, либо на предпоследнем доме.
Это связано с тем, что в процессе обхода грабитель может выбирать либо четные, либо нечетные дома.

Предположим, что грабитель завершает ограбление на последнем доме, тогда как узнать максимальную сумму награбленного?

В последний дом грабитель может прийти либо из 3-го дома с конца, либо из четвертого.
Так что зная максимальную сумму награбленного для третьего и четвертого с конца домов, несложно вычислить и сумму для последнего дома, выбрав максимум из двух и суммировав с текущим домом.
Тот же самый принцип валиден для третьего и для четвертого домов с конца (и для предпоследнего, в случае, если грабителю выгоднее закончить на предпоследнем доме).

Таким образом, развернув эту логику, мы получим оптимальное решение: если мы будем вычислять последовательно максимальную сумму награбленного для каждого из домов от начала улицы, то в одном из двух последних элементов массива будет искомое нами значение.

Алгоритм следующий:
- Первые 2 элемента остаются неизменными (так как мы начинаем с этих домов)
- Третий элемент массива заменяем на сумму первого элемента и оригинальное значение третьего элемента (так как в третий дом мы можем попасть только из первого)
- Для всех последующих элементов массива заменяем i'ый элемент на сумму оригинального значения i'го элемента с максимальным из двух (`i - 2` или `i - 3`)
- Возвращаем максимальный элемент из последнего и предпоследнего.

[Решение на GO](./go/solution.go)
[Решение на GO](./ts/solution.ts)

### Оценка сложности

**По времени**

Для того чтобы высчитать максимальную сумму награбленного, нам нужно один раз обойти исходный массив nums.
То есть итоговая сложность — `O(n)`.

**По памяти**

`O(1)` — дополнительная память константна, так как все изменения мы делали in-place.
