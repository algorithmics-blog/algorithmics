#  Longest Common Prefix (поиск самого длинного общего префикса в строках)

### Оглавление

- [Описание](#description)
- [Брутфорс](#bruteforce_1) - в данной задаче брутфорс является достаточно оптимальным решением

---

### <a name="description"></a>Описание

- Ссылка на задачу https://leetcode.com/problems/longest-common-prefix/
- Уровень #easy
- Входные данные: массив строк
- Выходные данные: строка, являющаяся самым длинным общим префиксом для всех строк массива

#### Примеры

###### Пример #1

- Входящие данные: ["flower","flow","flight"]
- Выходящие: "fl"

###### Пример #2

- Входящие данные: ["dog","racecar","car"]
- Выходящие: ""

#### Каких кейсов не хватает в примерах

- Пустой массив
- Массив из одной строки
- Строки разной длины, где одна из строк является префиксом (["dog", "dogs"])
- Одна из строк пустая (["dog", "dogs", """])

---

### <a name="bruteforce_1"></a> Брутфорс

#### Описание

Для того чтобы найти общей префикс у нескольких строк, нужно последовательно от 0-го символа 
сравнивать соответствующие по индексу символы в каждой строке. Если символы совпадают - значит текущий символ входит в общтй префикс. 
Как только мы находим первый несовпадающий символ (или заканчивается одна из строк) - значит общий префикс закончился.

Итоговый алгоритм:
- Выбираем одну из строк массива по которой будем итерироваться  (любую)
- создаем массив рун, куда будем складывать символы префикса
- Итерируемся по выбранной строке: если у всех остальных строк на соответствующем индексе стоит тот же самый символ что ъ
и у выбранной строки - добавляем символ в массив рун префикса. 
На первом несовпадающем символе (или если превышаем длину любой из строк) - прекращаем итерации и возвращаем префикс в виде строки.

#### Реализация

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }

    if len(strs) == 1 {
        return strs[0]
    }

    prefix := make([]rune, 0)
    firstStr := []rune(strs[0])
    runesStrs := make([][]rune, 0, len(strs))

    for i := 1; i < len(strs); i++ {
        if len([]rune(strs[i])) == 0 {
            return ""
        }

        runesStrs = append(runesStrs, []rune(strs[i]))
    }

loop:
    for idx, char := range firstStr {
        for _, runesStr := range runesStrs {
            if idx >= len(runesStr) {
                break loop
            }

            if runesStr[idx] != char {
                break loop
            }
        }

        prefix = append(prefix, char)
    }

    return string(prefix)
}

```


#### Оценка алгоритма

###### Сложность


 
- Для удобства работы (и поддержки мультибайтовых кодировок) преобразуем массив строк в массив массивов rune - 
сложность O(mn), где n - кол-во строк в массиве, m - максимальная длина строки
- Итерируемся по строке и сравниваем соответствующие текущему индексу символы в каждой из строк - O(mn)
  , где n - кол-во строк в массиве, m - максимальная длина строки
- Преобразуем массив рун префикса в строку - O(m), m - максимальная длина строки

Таким образом, сложность алгоритма O(mn + mn + m), где n - кол-во строк в массиве, m - максимальная длина строки.

Так как при оценке алгоритма нам важен только порядок роста функции (т.е. приниматься будет только
главный член формулы, отбросив все константы и константные множители), итоговая оценка - 
**O(mn), где n - кол-во строк в массиве, m - максимальная длина строки**

###### Память
Для удобства работы (и поддержки мультибайтовых кодировок) мы создали промежуточный массив массивов рун 
(представление строк в виде массива рун) размером mn, где n - кол-во строк в массиве, m - максимальная длина строки

Помимо этого мы собираем результат в массиве длиной m.

Таким образом дополнительная память - mn.