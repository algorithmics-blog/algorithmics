---
layout: post
title:  "Максимальный зигзагообразный путь в бинарном дереве"
complexity: medium
original_url: https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/description/
tag: medium
---

## Оглавление

- [Описание задачи](#описание-задачи)
- [Ограничения](#ограничения)
- [Пример](#пример)
- [Решение](#решение)

---

## Описание задачи

Напишите функцию, которая будет вычислять длину самого длинного зигзагообра́зного пути в бинарном дереве.
Путь может начинаться НЕ с корневого элемента дерева.

**Входные данные**

Ссылка на корневой элемент бинарного дерева.

**Выходные данные**

Длина максимального участка зигзагообра́зного пути.

---

## Ограничения

- Количество элементов в дереве от 1 до 50000

---

## Пример

{% tabs longest_zigzag_path_in_a_binary_tree %}

{% tab longest_zigzag_path_in_a_binary_tree Пример №1 %}
**Входные данные**:
![Дерево](/assets/images/binary_tree_zigzag_first_example.png)

**Ответ**: 3
{% endtab %}

{% tab longest_zigzag_path_in_a_binary_tree Пример №2 %}
**Входные данные**:
![Дерево](/assets/images/binary_tree_zigzag_second_example.png)

**Ответ**: 4
{% endtab %}
{% endtabs %}

---

## Решение

Для решения данной задачи нам придется вспомнить как работает алгоритм [DFS](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83) в деревьях и немного модифицировать его.

Нам нужно, чтобы поиск в глубину возвращал длину зигзага, который начинается слева от текущего элемента и справа.
Тогда, поднимаясь по дереву, мы легко сможем посчитать длину пути (необходимо помнить, что если мы идем от текущего элемента вправо, то от дочернего должны обязательно пойти влево и наоборот):
- Для каждого элемента дерева длина зигзага начинающегося с этого элемента налево равна длине зигзага дочернего элемента справа + 1
- Для каждого элемента дерева длина зигзага начинающегося с этого элемента направо равна длине зигзага дочернего элемента слева + 1

Если бы условия позволяли начинать путь только от корневого элемента, то нам бы хватило этих двух величин и на выходе нам нужно было только сравнить их между собой и вернуть максимум.
Но в данной задаче нам придется оперировать третьим параметром, чтобы не потерять дочерние пути (для простоты назовем его `maxLength`).

В этот параметр для каждого элемента мы будем складывать максимум из четырех значений:
- Длину зигзага, начинающегося от текущего элемента направо.
- Длину зигзага, начинающегося от текущего элемента налево.
- `maxLength` дочернего элемента слева
- `maxLength` дочернего элемента справа

Таким образом этот параметр позволит «всплывать» длинным путям дочерних элементов, чей зиг заг был «оборван» при подъеме по дереву во время поиска в глубину.

### Реализация

{% include code-example.md go_path="go/solution.go" ts_path="ts/solution.ts" %}

### Оценка сложности

**По времени**

`O(n)` — так как нам нужно совершить поиск в глубину по бинарному дереву, перебрав все `n` его элементов.

**По памяти**

`O(n)` — так как мы используем рекурсивный подход.

Это означает, что мы будем хранить в памяти `n` переменных во время вычисления стека рекурсии.