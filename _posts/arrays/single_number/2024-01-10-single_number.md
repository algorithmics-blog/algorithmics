---
layout: post
title:  "Неповторяющееся число"
complexity: easy
original_url: https://leetcode.com/problems/single-number
tag: easy
---

## Оглавление

- [Описание задачи](#описание-задачи)
- [Ограничения](#ограничения)
- [Примеры](#примеры)
- [Решение через хеш-таблицу](#решение-через-хеш-таблицу)
- [Решение через XOR](#решение-через-xor)

---

## Описание задачи

Дан непустой массив целых чисел `nums`, каждый элемент в котором появляется дважды, кроме одного.
Найдите этот уникальный элемент.

Вы должны реализовать решение с линейной сложностью по времени и памяти.

---

## Ограничения

- В массиве может быть от 1 до 3 * 10<sup>4</sup> элементов
- Каждый элемент массива имеет значение в диапазоне от -3 * 10<sup>4</sup> до 3 * 10<sup>4</sup>
- Каждый элемент массива встречается дважды, за исключением одного элемента

---

## Примеры

{% tabs single_number %}

{% tab single_number Пример №1 %}
**Входные данные**: `[2, 2, 1]`

**Ответ**: `1`
{% endtab %}

{% tab single_number Пример №2 %}
**Входные данные**: `[4, 1, 2, 1, 2]`

**Ответ**: `4`
{% endtab %}

{% tab single_number Пример №3 %}
**Входные данные**: `[1]`

**Ответ**: `1`
{% endtab %}

{% endtabs %}

---

## Решение через хеш-таблицу

Первая идея, которая может прийти в голову — реализовать классический обход массива с подсчетом частоты каждого числа.
Для этого для каждого числа в хеш-таблице мы будем хранить пару, в которой ключом является само число, а значением — сколько раз оно встречается в массиве.
В конце нужно будет лишь просмотреть всю таблицу и выбрать то число, у которого счетчик равен `1`.

Получим такое решение.

{% include code-example.md go_path="go/solution_map.go" ts_path="ts/solution_map.ts" %}

Однако, такое решение нам не подойдет, потому что использование хеш-таблицы для хранения частот приведет к тому, что у нас будет линейная сложность по памяти.

## Решение через XOR

На самом деле задача очень легкая, но надо знать хитрость, а именно — как работает операция `XOR`.

`XOR` — логическая операция исключающего `или` (обозначается знаком `⊕`) и у нее есть несколько полезных свойств, которые мы можем использовать.

1. `a ⊕ a = 0` — применение исключающего или к одинаковым операндам в результате дает ноль.
2. `b ⊕ 0 = b` — если в качестве одного операнда используется `0`, то результатом вычисления будет другой операнд.
3. `a ⊕ b ⊕ a = a ⊕ a ⊕ b` — операция XOR коммутативна, то есть мы можем менять порядок применения.

Исходя из этого мы можем вывести простое решение.

```a ⊕ b ⊕ a = (a ⊕ a) ⊕ b = 0 ⊕ b = b```

То есть, нам достаточно последовательно применить операцию XOR ко всем элементам в массиве. 
Пары одинаковых значений взаимно «уничтожатся» и в конечном счете останутся всего два операнда — `0` и уникальное число, 
а результатом применения XOR между ними будет само уникальное число.  

### Реализация

{% include code-example.md go_path="go/solution.go" ts_path="ts/solution.ts" %}

## Оценка сложности

`n` - количество элементов в массиве.

**По времени**

Сложность по времени `O(n)`, так как мы итерируемся по всем элементам массива.

**По памяти**

Сложность по памяти `O(1)`, так как мы не создаем дополнительных переменных.
