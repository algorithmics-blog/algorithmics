---
layout: post
title:  "Контейнер с наибольшим количеством воды"
complexity: medium
original_url: https://leetcode.com/problems/container-with-most-water/
tag: medium
---

## Оглавление

- [Описание задачи](#описание-задачи)
- [Ограничения](#ограничения)
- [Примеры](#примеры)
- [Брутфорс решение](#брутфорс-решение)
- [Решение через скользящее окно](#решение-через-скользящее-окно)

---

## Описание задачи

![Контейнер с водой](/assets/images/container_with_water.png)

Вам дан целочисленный массив высот `height` длиною `n`.

Найдите две линии, которые вместе с осью X образуют контейнер, в котором содержится больше всего воды.
Верните из функции максимальное количество воды, которое может хранить контейнер.

Задача сводится к поиску прямоугольника максимальной площади.

---

## Ограничения

- В массиве всегда есть минимум 2 элемента
- Значения элементов могут быть в диапазоне от 0 до 104

---

## Примеры

{% tabs examples %}

{% tab examples Пример №1 %}

**Входные данные**: `[1,8,6,2,5,4,8,3,7]`

**Ответ**: `49`

Максимальная площадь прямоугольника при выборе второй и последней высот в массиве (8, 7).
Тогда высота квадрата — 7 и длина — 7 (индексы «высот» 8 и 1, разница индексов — 7)

{% endtab %}

{% tab examples Пример №2 %}

**Входные данные**: `[1,1]`

**Ответ**: `1`

С массивом из 2-х элементов возможен только один возможный прямоугольник `min(a[0], a[1]) * (1 - 0)`

{% endtab %}

{% endtabs %}

---

## Брутфорс решение

Задачу можно разделить на 2 этапа:
- поиск всех возможных площадей всех возможных прямоугольников с сохранением результатов в промежуточный массив;
- поиск максимума в массиве.

Вычисление всех возможных площадей прямоугольников:
```go
squares := make([]int, 0, len(height)*len(height))

for i := 0; i < len(height)-1; i++ {
    for j := i + 1; j < len(height); j++ {
        minHeight := height[i]
        if height[j] < minHeight {
            minHeight = height[j]
        }

        squares = append(squares, minHeight*(j-i))
    }
}
```

Поиск максимума:
```go
res := 0
for _, square := range squares {
    if square > res {
        res = square
    }
}
```

### Небольшие улучшения

Можно заметить, что для вычисления максимумов нам нет нужды сохранять площади в промежуточный массив,
мы можем проверять сравнивать и сохранять максимальную площадь в момент расчета:

```go
func maxArea(height []int) int {
  res := 0
  for i := 0; i < len(height)-1; i++ {
      for j := i + 1; j < len(height); j++ {
          minHeight := height[i]
          if height[j] < minHeight {
              minHeight = height[j]
          }
          
          square := minHeight*(j-i)
          if square > res {
              res = square
          }
      }
  }

  return res
}
```

Таким образом мы избавляемся от необходимости хранить дополнительный массив `squares` размером <code>n<sup>2</sup></code> и отдельно вычислять
максимумы в этом массиве и при этом уменьшаем сложность алгоритма по памяти с квадратичной до константной.

> P.S. Несмотря на то, что мы избавились от дополнительного обхода массива squares, на итоговую сложность алгоритма
по времени это не повлияло, так в оценке нам важен порядок роста, который остался прежним, так как мы все еще обходим
входящий массив «циклом в цикле».


### Улучшаем алгоритм дальше

Можно попробовать еще немного улучшить алгоритм, отбросив заведомо лишние действия. 
Для этого вложенный цикл запустим не от следующего за `i` элемента, а от максимально далекого.
Таким образом мы сперва проверяем прямоугольники с максимальной длиной.
В этом случае мы сможем добавить условие выхода из внутреннего цикла
(не уменьшать дальше длины прямоугольника, так как все прямоугольники с меньшей длинной при заданном `i` окажутся заведомо меньшей площади).

```go
length := j - i

if length * height[i] < res {
    break
}
```

В итоге мы получим следующее решение.

{% include code-example.md go_path="go/solution_bruteforce.go" ts_path="ts/solution_bruteforce.ts" %}

### Оценка сложности

**По времени**

Для того чтобы вычислить все возможные площади, необходимо перебрать все возможные комбинации 2-х элементов в массиве.
Это сводится к «циклу в цикле», что можно прировнять к сложности <code>O(n<sup>2</sup>)</code>

Для того чтобы найти максимум в массиве, нужно перебрать весь получившийся массив один раз.
Так как массив `squares` имеет размер ~n<sup>2</sup>, то сложность также сводится к <code>O(n<sup>2</sup>)</code>.

То есть суммарная оценка <code>O(n<sup>2</sup>)</code> + <code>O(n<sup>2</sup>)</code> = <code>O(2n<sup>2</sup>)</code>

Так как при оценке алгоритма нам важен только порядок роста функции (т.е. приниматься будет только
главный член формулы без учета константных множителей), итоговая оценка - <code>O(n<sup>2</sup>)</code>

**По памяти**

Сложность по памяти константная `O(1)`.

---

## Решение через скользящее окно

Для решения подобных задач оптимальным подходом может оказаться «скользящее окно».
Идея состоит в том, чтобы выбрать некое окно и в зависимости от условий сдвигать одну или обе границы окна в сторону.

В нашем случае в качестве первоначального «окна» мы можем взять весь массив.
Так же как и в [улучшенном брутфорсе](#улучшаем-алгоритм-дальше) начинаем с прямоугольника максимальной длины.
Окно мы будем сужать, пока не дойдем до единичного отрезка в длину.
Так как в качестве первоначального окна мы берем прямоугольник с максимальной длиной, 
то единственный способ получить прямоугольник большей площади при уменьшении длины — увеличение высоты.


Таким образом, нам нужно сужать прямоугольник со стороны меньшей из высот, чтобы увеличить минимальную высоту «аквариума».
На каждой итерации считаем площадь нового прямоугольника и сравниваем с максимумом.
В случае, если и левая и правая сторона «аквариума» одинаковы — «сужаем» окно с обоих направлений.

{% include code-example.md go_path="go/solution.go" ts_path="ts/solution.ts" %}

### Оценка сложности

**По времени**

На каждой итерации мы двигаем либо правую, либо левую границу окна. Таким образом, суммарно мы подвинем границу `O(n - 1)` раз. 
Это единственная переменная величина. Таким образом, алгоритм имеет линейный порядок роста `O(n)`.

**По памяти**

Мы никак не преобразуем входящие данные и не храним промежуточные результаты (как в случае с [брутфорсом](#брутфорс-решение)).
Сложность по памяти константная — `O(1)`.