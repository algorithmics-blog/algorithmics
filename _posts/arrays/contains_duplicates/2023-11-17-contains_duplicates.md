---
layout: post
title:  "Проверка массива на дубликаты"
complexity: easy
original_url: https://leetcode.com/problems/contains-duplicate/description/
tag: easy
---

## Оглавление

- [Описание задачи](#описание-задачи)
- [Ограничения](#ограничения)
- [Примеры](#примеры)
- [Решение через Hash Map](#решение-через-hash-map)
- [Решение через сортировку](#решение-через-сортировку)

---

## Описание задачи

Дан целочисленный массив.
Напишите функцию, которая принимает на вход массив и возвращает `true`, если какое-либо значение встречается в массиве более одного раза.
Если каждое значение в массиве уникально, то функция должна возвращать `false`.

---

## Ограничения

- В массиве может быть от 1 до 10<sup>5</sup> элементов
- Каждое значение может быть в диапазоне от -10<sup>9</sup> до 10<sup>9</sup>

---

## Примеры

{% tabs contains_duplicates_examples %}

{% tab contains_duplicates_examples Пример №1 %}

**Входные данные**: `[1, 2, 3, 1]`

**Ответ**: `true`

{% endtab %}

{% tab contains_duplicates_examples Пример №2 %}

**Входные данные**: `[1, 2, 3, 4]`

**Ответ**: `false`

{% endtab %}

{% endtabs %}

---

## Решение через Hash Map

Для решения задачи этим способом достаточно проитерироваться по всем элементам массива.
На каждой итерации нужно подсчитывать количество значений, которые встречаются.
Для этого можно использовать структуру `Hash Map`:
- если в мапе не существует такого значения, то мы добавляем его туда и переходим к следующей итерации;
- если в мапе уже есть такое значение, то мы прерываем функцию и возвращаем `true`.

{% include code-example.md go_path="go/solution_map.go" ts_path="ts/solution_map.ts" %}

### Оценка сложности

**По времени**

Сложность `O(n)`, где `n` — количество элементов в массиве, так как в худшем случае мы пройдем в цикле по всем элементам.

**По памяти**

Сложность `O(n)`, так как мы выделяем мапу для хранения частот значений.

## Решение через сортировку

Для решения задачи этим способом необходимо предварительно отсортировать массив в любом порядке.
Так как в отсортированном массиве одинаковые значения всегда находятся рядом, нам будет достаточно пройти по всем элементам массива и вернуть `true`, если мы встретим два одинаковых значения рядом.

{% include code-example.md go_path="go/solution_sort.go" ts_path="ts/solution_sort.ts" %}

### Оценка сложности

**По времени**

Сложность алгоритма равна сложности сортировки, так как она больше линейной — `O(n * logn)`.

**По памяти**

Сложность `O(1)`, так как мы не выделяем дополнительной памяти.