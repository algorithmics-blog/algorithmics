---
layout: post
title:  "Игра в грабителя"
complexity: medium
original_url: https://leetcode.com/problems/house-robber/description
tag: medium
---

## Оглавление

- [Описание задачи](#описание-задачи)
- [Ограничения](#ограничения)
- [Примеры](#примеры)
- [Брутфорс решение](#брутфорс-решение)
- [Оптимальное решение](#оптимальное-решение)

---

## Описание задачи

Вы профессиональный грабитель, планирующий грабить дома на улице.
В каждом доме спрятана определенная сумма денег.
Единственное ограничение, которое мешает вам ограбить каждый из них это то, что в соседних домах подключены системы безопасности, и они автоматически свяжутся с полицией, если в одну ночь взломали два соседних дома.

Вам дан массив чисел, представляющий сумму денег в каждом доме. 
Верните максимальную сумму денег, которую вы можете украсть сегодня вечером, не предупредив полицию.

Входные данные: []int (сумма, которую грабитель может украсть в соответствующем доме)

Выходные данные: int (максимальная сумма грабежа)

---

## Ограничения

- Количество домов (длина массива) - от 1 до 100
- Сумма денег в каждом доме находится в диапазоне от 0 до 400

---

## Примеры

{% tabs house_robber_examples %}

{% tab house_robber_examples Пример №1 %}
**Входные данные**: `[1, 2, 3, 1]`

**Ответ**: `4`

Оптимальное решение — первый и третий дом.
{% endtab %}

{% tab house_robber_examples Пример №2 %}
**Входные данные**: `[2, 7, 9, 3, 1]`

**Ответ**: `12`

Оптимальное решение — первый, третий и пятый дом.
{% endtab %}

{% tab house_robber_examples Пример №3 %}
**Входные данные**: `[1]`

**Ответ**: `1`

Так как дом всего один — он и есть оптимальное решение.
{% endtab %}

{% tab house_robber_examples Пример №4 %}
**Входные данные**: `[2, 1]`

**Ответ**: `2`

Оптимальное решение — первый дом.
{% endtab %}

{% tab house_robber_examples Пример №5 %}
**Входные данные**: `[100, 9, 10, 9, 1, 100]`

**Ответ**: `210`

Оптимальное решение — первый, третий и шестой дом.
Этот пример важен, потому что в процессе ограбления выгоднее всего после третьего дома пропустить не один, а сразу два дома (т.е. перейти с нечетных домов, на четные).
{% endtab %}

{% endtabs %}

## Брутфорс решение

Первое, что может прийти в голову, сгенерировать и посчитать все возможные комбинации. 
Такое решение будет обладать достаточно большой сложностью, так как после каждого дома у грабителя будет возможность пойти по двум маршрутам: через один и через два дома.
Не будем задерживаться на этом подходе, так как оптимальное решение и проще реализовать и оно существенно быстрее.
Но, так как подобное решение самое очевидное на старте, оставим ссылки на реализацию:

- [Решение на GO](https://github.com/avivasyuta/algorithmics/blob/main/_posts/arrays/house_robber/go/bruteforce.go)
- [Решение на TS](https://github.com/avivasyuta/algorithmics/blob/main/_posts/arrays/house_robber/ts/solution.go)

### Оценка сложности

**По времени**

Длина любой последовательности не может превышать `n/2`.
После каждого дома возможно разветвление маршрута на 2 — пойти либо в дом через один, либо через два.
Таким образом, общее количество маршрутов можно оценить как <code>2<sup>n/2</sup></code>.

Так как для нахождения максимума нам нужно пройтись по каждому из этих маршрутов, итоговую оценку сложности можно также оценить в <code>O(2<sup>n/2</sup>)</code>.

**По памяти**

<code>O((n/2) * 2<sup>n/2</sup>)</code> — дополнительная память для того, чтобы сохранить все возможные маршруты.

## Оптимальное решение

Это задача из тех, которую можно реализовать используя подход динамического программирования.
Грабитель может закончить либо на последнем доме, либо на предпоследнем доме.
Это связано с тем, что в процессе обхода грабитель может выбирать либо четные, либо нечетные дома.

Предположим, что грабитель завершает ограбление на последнем доме, тогда как узнать максимальную сумму награбленного?

В последний дом грабитель может прийти либо из 3-го дома с конца, либо из четвертого.
Так что зная максимальную сумму награбленного для третьего и четвертого с конца домов, несложно вычислить и сумму для последнего дома, выбрав максимум из двух и суммировав с текущим домом.
Тот же самый принцип валиден для третьего и для четвертого домов с конца (и для предпоследнего, в случае, если грабителю выгоднее закончить на предпоследнем доме).

Таким образом, развернув эту логику, мы получим оптимальное решение: если мы будем вычислять последовательно максимальную сумму награбленного для каждого из домов от начала улицы, то в одном из двух последних элементов массива будет искомое нами значение.

Алгоритм следующий:
- Первые 2 элемента остаются неизменными (так как мы начинаем с этих домов)
- Третий элемент массива заменяем на сумму первого элемента и оригинальное значение третьего элемента (так как в третий дом мы можем попасть только из первого)
- Для всех последующих элементов массива заменяем i'ый элемент на сумму оригинального значения i'го элемента с максимальным из двух (`i - 2` или `i - 3`)
- Возвращаем максимальный элемент из последнего и предпоследнего.

{% include code-example.md go_path="go/solution.go" ts_path="ts/solution.ts" %}

### Оценка сложности

**По времени**

Для того чтобы высчитать максимальную сумму награбленного, нам нужно один раз обойти исходный массив `nums`.
То есть итоговая сложность — `O(n)`.

**По памяти**

`O(1)` — дополнительная память константна, так как все изменения мы делали in-place.
