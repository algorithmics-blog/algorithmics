---
layout: post
title:  "Сумма двух чисел в массиве"
complexity: easy
original_url: https://leetcode.com/problems/two-sum/
tag: easy
---

## Оглавление

- [Описание задачи](#описание-задачи)
- [Ограничения](#ограничения)
- [Примеры](#примеры)
- [Решение](#решение)

---

## Описание задачи

Дан массив целых чисел `nums`.
Напишите функцию `twoSum` для поиска в массиве двух чисел, сумма которых равна целевому
числу `target`.
В качестве результата функция должна возвращать массив с индексами элементов удовлетворяющих условию.
Порядок индексов в ответе не важен.

---

## Ограничения

- В массиве может быть от 2 до 10<sup>4</sup> уникальных значений
- В качестве значений могут быть числа в диапазоне от -10<sup>9</sup> до 10<sup>9</sup>
- Значение `target` может быть в диапазоне от -10<sup>9</sup> до 10<sup>9</sup>
- Для массива всегда есть только одно решение

---

## Примеры

{% tabs two_sum %}

{% tab two_sum Пример №1 %}
**Входные данные**

```
nums = [2, 7, 11, 15]
target = 9
```

**Ответ**: `[0, 1]` или `[1, 0]`

Сумма 2 и 7 равна 9. Следовательно, `index1` = 0, `index2` = 1.<br>
Возвращаем `[0, 1]`.
{% endtab %}

{% tab two_sum Пример №2 %}
**Входные данные**

```
nums = [-1, 0]
target = -1
```

**Ответ**: `[0, 1]` или `[1, 0]`

Сумма -1 и 0 равна -1. Следовательно, `index1` = 0, `index2` = 1.<br>
Возвращаем `[0, 1]`.
{% endtab %}

{% endtabs %}

---

## Решение

Для того чтобы эффективно решить эту задачу, надо придумать, как получать индекс числа из массива не перебирая его.
В этом нам может помочь структура `Hash Map` (или ее аналоги), которая позволяет получать значение по ключу за константное время.

Изначально мы инициализируем пустую мапу, в которую будем записывать в качестве ключа число, а в качестве значения — его индекс в массиве.
Далее запускаем цикл по всем элементам массива, в котором выполняем следующие проверки на каждой итерации.

1. Высчитываем разницу между `target` и текущим числом из массива. Это второе искомое число, которое нам нужно.
2. Чтобы проверить, есть ли число в массиве, мы обращаемся в нашу мапу с текущим числом в качестве ключа.
Если в мапе есть такое число, значит мы его уже ранее добавляли из массива и можем получить его индекс.
Мы нашли искомую пару чисел и можем вернуть их индексы в виде массива в качестве ответа.
3. Если в мапе нет такого числа, значит нужно его туда добавить. В качестве ключа используем само число, а в качестве значения его индекс.

{% include code-example.md go_path="go/solution.go" ts_path="ts/solution.ts" %}

### Оценка сложности

`n` - количество элементов в массиве.

**По времени**

Сложность по времени `O(n)`, так как мы итерируемся по всем элементам массива.

**По памяти**

Сложность по памяти `O(n)`, так как мы добавляем в мапу `n` элементов.