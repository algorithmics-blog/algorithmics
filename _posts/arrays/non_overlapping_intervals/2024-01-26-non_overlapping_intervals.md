---
layout: post
title:  "Непересекающиеся интервалы"
complexity: medium
original_url: https://leetcode.com/problems/non-overlapping-intervals/
tag: medium
---

## Оглавление

- [Описание задачи](#описание-задачи)
- [Ограничения](#ограничения)
- [Примеры](#примеры)
- [Решение](#решение)

---

## Описание задачи

Дан массив интервалов `intervals`, где <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>.
Напишите функцию, которая возвращает минимальное количество интервалов, которое вам нужно удалить, чтобы остальные интервалы не пересекались.

---

## Ограничения

- Длина массива находится в диапазоне от 1 до 10<sup>5</sup>
- Каждый элемент массива также является массивом из двух элементов
- Значения границ интервалов находятся в диапазоне от -5 * 10<sup>4</sup> до 5 * 10<sup>4</sup>
- Нижняя граница интервала всегда меньше верхней

---

## Примеры

{% tabs non_overlapping_intervals %}

{% tab non_overlapping_intervals Пример №1 %}

**Входные данные**: `[[1,2],[2,3],[3,4],[1,3]]`

**Ответ**: `1`

Интервал `[1,3]` можно удалить, а остальные не перекрываются.

{% endtab %}

{% tab non_overlapping_intervals Пример №2 %}

**Входные данные**: `[[1,2],[1,2],[1,2]]`

**Ответ**: `2`

Нужно удалить два интервала `[1,2]`, чтобы остался один не пересекающийся.

{% endtab %}

{% tab non_overlapping_intervals Пример №3 %}

**Входные данные**: `[[1,2],[2,3]]`

**Ответ**: `0`

Не нужно удалять какие-либо интервалы, поскольку они уже не перекрываются.

{% endtab %}

{% endtabs %}

---

## Решение

Рассмотрим два интервала с самым ранним временем окончания.
Допустим, более раннее время окончания — `x`, а более позднее — `y`, то есть `х < у`.

Если мы можем сохранить только один интервал, следует ли нам выбрать тот, который заканчивается на `x` или тот, который оканчивается на `y`?
Чтобы избежать дублирования, мы всегда должны жадно выбирать интервал с более ранним временем окончания `x`.
Логику, стоящую за этим, можно описать следующим образом:

- Мы выбираем либо `x`, либо `y`. Назовем наш выбор `k`.
- Чтобы избежать пересечения, время начала следующего интервала, который мы выбираем, должно быть больше или равно `k`.
- Мы хотим максимизировать интервалы, которые мы используем (без пересечения), поэтому мы хотим максимизировать выбор для следующего интервала.
- Поскольку время начала следующего интервала должно быть больше или равно `k`, большее значение `k` никогда не сможет дать нам больше выбора, чем меньшее значение `k`.
- Таким образом, мы должны попытаться минимизировать `k`. Следовательно, нам всегда следует жадно выбирать `x`, поскольку `x < y`.

В общем, `k` равно времени окончания самого последнего сохраненного нами интервала.

Решение задачи мы начинаем с сортировки интервалов по времени окончания, чтобы мы могли обрабатывать интервалы по порядку.

Поскольку мы отсортировали интервалы по времени окончания, `y` должно быть больше `k`.
Это дает нам два возможных варианта:

- Вариант 1, `x >= k`: мы можем смело использовать этот интервал, поскольку он не приведет к пересечению.
- Вариант 2, `x < k`: использование этого интервала приведет к пересечению.
Как мы установили ранее, нам всегда следует брать интервалы с более ранним временем окончания. Поскольку `y > k`, мы должны удалить текущий интервал.

### Реализация

{% include code-example.md go_path="go/solution.go" ts_path="ts/solution.ts" %}

### Оценка сложности

**По времени**

Для того чтобы найти ответ, нам достаточно один раз пройтись по исходному массиву со сложностью `O(n)`.
Однако предварительно мы еще делаем сортировку массива, сложность которой скорее всего равна <code>O(n⋅log<sub>n</sub>)</code>).

Поэтому итоговая сложность по времени равна <code>O(n⋅log<sub>n</sub>)</code>.

**По памяти**

Мы не создаем переменных, зависящих от длины входных данных, однако для сортировки также требуется выделение памяти.
В разных языках используются разные алгоритмы, поэтому сложность по памяти будет варьироваться от <code>O(log<sub>n</sub></code>) до `O(n)`.
