---
layout: post
title:  "Сжатие строки"
complexity: medium
original_url: https://leetcode.com/problems/string-compression/description/
tag: medium
---

## Оглавление

- [Описание задачи](#описание-задачи)
- [Ограничения](#ограничения)
- [Примеры](#примеры)
- [Решение](#решение)

---

## Описание задачи

Дана строка в виде массива байт. Необходимо написать функцию, которая сожмет входящий массив по следующему принципу:
- Если символ повторяется больше одного раза подряд, нужно заменить всю подстроку на строку `['a', 'n']`, где `a` - исходный символ, `n` - количество повторений этого символа, идущих подряд. В случае если n многозначное число, каждая цифра должна быть добавлена отдельным символом.
- Если буква не повторяется - оставить ее без изменений.

Все изменения нужно совершить in-place, в качестве ответа функции вернуть количество символов в сжатой строке.

---

## Ограничения

- Длина входящего массива от 1 до 2000 символов
- Элементы массива - символы латиницы, цифры или знаки

---

## Примеры

{% tabs string_compression %}

{% tab string_compression Пример №1 %}
**Входные данные**

```
chars = ["a","a","b","b","c","c","c"]
```

**Ответ**: `6`

Исходный массив должен быть преобразован в `["a","2","b","2","c","3"]` 
{% endtab %}

{% tab string_compression Пример №2 %}
**Входные данные**

```
chars = ["a"]
```

**Ответ**: `1`
{% endtab %}

{% tab string_compression Пример №3 %}
**Входные данные**

```
chars = chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
```

**Ответ**: `4`

Исходный массив должен быть преобразован в `["a","b","1","2"]`
{% endtab %}

{% endtabs %}

## Решение

Задача решается достаточно элементарно, главная загвоздка - замена элементов in-place.

Для решения нам потребуется несколько индексов:
- Индекс текущего элемента `lastElemIdx`
- Индекс начал последовательности одинаковых элементов `firstElemIdx`
- Индекс элемента, который будет заменен при сжатии строки `newPositionIdx` (для эффективности решения мы будем заменять элементы исходного массива, а после «отрежем» хвост. В противном случае нам бы пришлось вырезать повторяющиеся символы, смещая хвост массива на n элементов влево, что значительно замедлит алгоритм)

Мы будем итерироваться по исходному масиву:
- Пока текущий символ равен предыдущему, мы двигаемся вперед, запоминая последний индекс повторяющегося символа
- В случае если текущий элемент не равен предыдщему (или же мы дошли до конца исходного массива):
  1. Заносим элемент, который мы запомнили в исходный массив на позицию `newPositionIdx`
  2. Инкрементируем `newPositionIdx`
  3. При необходимости разницу между `lastElemIdx` и `firstElemIdx` прервращаем в строку и посимвольно добавляем в следующие ячейки массива (и инкрементируем `newPositionIdx` для каждого вставленного символа)
  4. Запоминаем новый символ как начало следующей последовательности и переносим позицию `firstElemIdx`

В конце нам останется «отрезать» хвост у исходного массива

{% include code-example.md go_path="go/solution.go" ts_path="ts/solution.ts" %}

### Оценка сложности

`n` - количество элементов в массиве.

**По времени**

Сложность по времени `O(n)`, так как мы итерируемся по всем элементам массива.

**По памяти**

Сложность по памяти `O(1)`, так как мы модифицируем массив in-place.
