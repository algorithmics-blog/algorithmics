---
layout: post
title:  "Разворот целого числа"
complexity: medium
original_url: https://leetcode.com/problems/reverse-integer/description/
tags: [medium, math, integers]
---

## Оглавление

- [Описание задачи](#описание-задачи)
- [Ограничения](#ограничения)
- [Примеры](#примеры)
- [Решение](#решение)

---

## Описание задачи

Дано 32-битное целое число `x` со знаком.
Напишите функцию `reverse`, которая принимает на вход `x`, а возвращает перевернутое число.

Если изменение `x` приводит к выходу значения за пределы диапазона 32-битных целых чисел со знаком <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code>, верните `0`.
Учтите, что среда исполнения функции не позволяет хранить 64-битные целые числа со знаком или без знака.

---

## Ограничения

- Значение `x` находится в диапазоне от <code>-2<sup>31</sup></code> до <code>2<sup>31</sup> - 1</code>

---

## Примеры

{% tabs reverse-integer %}

{% tab reverse-integer Пример №1 %}
**Входные данные**: `x = 123`

**Ответ**: `321`
{% endtab %}

{% tab reverse-integer Пример №2 %}
**Входные данные**: `x = -123`

**Ответ**: `-321`
{% endtab %}

{% tab reverse-integer Пример №3 %}
**Входные данные**: `x = 120`

**Ответ**: `21`
{% endtab %}

{% tab reverse-integer Пример №4 %}
**Входные данные**: `x = 2147483647`

**Ответ**: `0`

Перевернутое число `7463847421` выходит за пределы 32-битного диапазона.
{% endtab %}

{% tab reverse-integer Пример №5 %}
**Входные данные**: `x = -2147483647`

**Ответ**: `0`

Перевернутое число `-7463847421` выходит за пределы 32-битного диапазона.
{% endtab %}

{% endtabs %}

---

## Решение

Для решения задачи сначала попытаемся понять, как развернуть простое маленькое число, например `123`.

Интуитивно понятно, что нам нужно взять последнюю цифру в числе и поместить ее на первое место.
Такой трюк надо провернуть столько раз, чтобы все число развернулось.

Получить последнюю цифру от числа крайне просто, так как это остаток от деления числа на десять.
Получить же «левую» часть можно оставив лишь целую часть от деления числа на 10.

```typescript
right = x % 10
left = x / 10
```

То есть мы получим следующие значения.

```typescript
right = 3
left = 12
```

А вот из последне цифры сделать первую уже немного сложнее.

Для начала создадим переменную `res`, которая на старте будет равна `0` и в которой мы будем хранить итоговое число.
Чтобы в нашем результате последняя цифра стала первой, достаточно к `res` прибавить `right`.

```typescript
res = res + right
```

Таким образом после первой итерации мы имеем следующие значения.

```typescript
left = 12
right = 3
res = 3
```

Теперь надо повторить вычисления. Выделяем новую левую часть и последнюю цифру. 

```typescript
left = 1
right = 2
res = 3
```

Теперь, если мы попробуем прибавить к `res` правую цифру, то получим `2 + 3 = 5`, что будет неверным ответом.
Нам надо сделать так, чтобы добавленная цифра занимала следующий разряд.
Для этого нам сначала нужно `res` умножить на `10`.
Таким образом мы получим `30` вместо `3`, а добавив к числу `2`, получим `32`, что уже является корректной последовательностью.

Исходя из этого правильная формула для вычисления `res` будет выглядеть так.

```typescript
res = res * 10 + right
```

Проделываем итерацию еще раз и получаем итоговые значения.

```typescript
left = 0
right = 1
res = 321
```

Как мы видим, после обработки последней цифры `left` всегда будет равен `0`, поэтому цикл мы будем выполнять до тех пор, пока `left != 0`.

{% tabs reverse-integer_sol1 %}
{% tab reverse-integer_sol1 GO %}
```go
package main

func reverse(x int) int {
	left := x
	res := 0

	for left != 0 {
		right := left % 10
		left = left / 10
		res = res*10 + right
	}

	return res
}
```
{% endtab %}

{% tab reverse-integer_sol1 Type Script %}
```typescript
export const reverse = (x: number): number => {
    let left = x
    let res = 0

    while (left != 0) {
        const right = left % 10
        // Округляем число в зависимости от знака
        left = left > 0 ? Math.floor(left / 10) : Math.ceil(left / 10)

        res = res * 10 + right
    }

    return res
}

```
{% endtab %}
{% endtabs %}

### Превышение 32-битного пространство

Как было сказано в условиях задачи, число не может превышать диапазон 32-битного пространства <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code>.
Это значит, что если мы попытаемся развернуть число `2147483647`, то на последней итерации мы получим `7463847412`, а оно сильно выходит за допустимые границы.

Как же нам обработать переполнение?

Давайте определим, что верхняя граница 32-битного диапазона называется `MAX_INT`, а нижняя — `MIN_INT`.
Теперь сформулируем несколько правил.

**Для положительных чисел**

- Если `res > MAX_INT / 10`, то после умножения его на 10 и добавления к нему `right` мы гарантированно получим переполнение.
- Если `res == MAX_INT / 10` то после умножения его на 10 и добавления к нему `right` мы получим переполнение только если `right > 7`.

**Для отрицательных чисел**

- Если `res < MIN_INT / 10`, то после умножения его на 10 и добавления к нему `right` мы гарантированно получим переполнение.
- Если `res == MIN_INT / 10` то после умножения его на 10 и добавления к нему `right` мы получим переполнение только если `right < -7`.


### Реализация

Обратите внимание, что в Type Script приходится дополнительно округлять числа с плавающей точкой в зависимости от знака.
Также тут нет констант для минимального и максимального 32-битных чисел

{% include code-example.md go_path="go/solution.go" ts_path="ts/solution.ts" %}

### Оценка сложности

**По времени**

Для вычисления степени нам нужно произвести `k` итераций, где `k` — количество цифр в числе, что примерно равно`log(x)`.
Поэтому сложность `O(log(x))`

**По памяти**

`O(1)` — дополнительная память константна.