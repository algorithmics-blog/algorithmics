---
layout: post
title:  "Игра в жизнь"
complexity: medium
original_url: https://leetcode.com/problems/game-of-life/description/
tag: medium
---

## Оглавление

- [Описание](#description)
- [Ограничения](#restrictions)
- [Примеры](#examples)
- [Решение](#solution)

---

## <a name="description"></a>Описание

Механика игры подробно описана в [статье википедии](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life).

Доска состоит из сетки ячеек размером `m x n`, где каждая ячейка имеет начальное состояние:
- живое — обозначается цифрой `1`
- мертвое — обозначается цифрой `0`.

Каждая ячейка взаимодействует со своими восемью соседями (горизонтальными, вертикальными, диагональными), используя следующие четыре правила.

1. Любая живая клетка, имеющая менее двух живых соседей, умирает, как из-за недостаточной численности населения.
2. Любая живая клетка с двумя или тремя живыми соседями доживает до следующего поколения.
3. Любая живая клетка, имеющая более трех живых соседей, погибает от перенаселения.
4. Любая мертвая клетка, имеющая ровно три живых соседа, становится живой клеткой путем размножения.

Следующее состояние доски создается путем одновременного применения вышеуказанных правил к каждой ячейке в текущем состоянии, где рождение и смерть происходят одновременно.

Напишите функцию, которая принимает на вход матрицу состояния и изменяет ее до следующего состояния.

## <a name="restrictions"></a>Ограничения

- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 25`
- `board[i][j] == 0 || board[i][j] == 1`

## <a name="examples"></a>Примеры

### Пример 1

![Пример 1](resources/matrix.png)

```
Вход: [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]
```

```
Ответ: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]
```

### Пример 2

![Пример 2](resources/matrix2.png)

```
Вход: [[1,1],[1,0]]
```

```
Ответ: [[1,1],[1,1]]
```

## <a name="solution"></a>Решение

Эту задачу очень просто решить, если реализовать изменение матрицы в ее копии.
Это делает алгоритм очень простым, но требует выделения дополнительной памяти, что может стать проблемой при большом количестве данных.

Чтобы иметь оптимальное потребление памяти, нужно производить все изменения in-place.
Если мы будем просто менять состояние в исходной матрице при проверке каждого элемента, то мы потеряем исходное состояние и не сможем корректно проверять необходимость мутации.

Для того чтобы это обойти введем два новых значения для матрицы.

1. `2` обозначает переход нуля в единицу. Мы будем использовать двойку в качестве значения, чтобы пометить неживые клетки, которые должны стать живыми по итогам наших расчетов.
2. `3` обозначает переход единицы в ноль. Мы будем использовать тройку в качестве значения, чтобы пометить живые клетки, которые должны стать неживыми по итогам наших расчетов.

При вычислении состояния для каждой клетки нужно учитывать эти нововведения.
В конце после того, как мы поменяем состояния для всех элементов матрицы нужно еще раз обновить ее и заменить все `2` на `0`, а `3` на `1`.

[Решение на GO](go/solution.go)

[Решение на TypeScript](ts/solution.ts)

### Оценка сложности

**По времени**

`O(m * n)` так как мы обходим всю матрицу поэлементно.

**По памяти**

`O(1)` так как мы не выделяем дополнительную память.