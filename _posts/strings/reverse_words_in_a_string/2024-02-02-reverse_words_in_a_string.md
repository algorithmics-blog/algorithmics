---
layout: post
title:  "Разворот слов в строке"
complexity: medium
original_url: https://leetcode.com/problems/reverse-words-in-a-string/description/
tag: medium
---

## Оглавление

- [Описание задачи](#описание-задачи)
- [Ограничения](#ограничения)
- [Примеры](#примеры)
- [Решение](#решение)

---

## Описание задачи

Необходимо написать функцию, которая будет переставлять слова в строке в обратном направлении.
Слова в строке разделены пробелами, пробелов между слов может быть несколько, а также пробелы могут стоять в начале и конце исходной строки.

В итоговой строке слова должны быть разделены одним пробелом, а также не должно быть пробелов в начале и конце строки.

---

## Ограничения

- Длина строки может быть в диапазоне от 1 до 10000
- Строка содержит только буквы латинского алфавита, числа и пробелы.
- В каждой строке есть как минимум одно слово

---

## Примеры

{% tabs reverse_words_in_a_string %}
{% tab reverse_words_in_a_string Пример №1 %}
**Входные данные**: `"the sky is blue"`

**Ответ**: `blue is sky the`

{% endtab %}

{% tab reverse_words_in_a_string Пример №2 %}
**Входные данные**: `  hello world  `

**Ответ**: `world hello`

{% endtab %}

{% tab reverse_words_in_a_string Пример №3 %}
**Входные данные**: `a good   example`

**Ответ**: `example good a`

{% endtab %}
{% endtabs %}

---

## Решение

Данную задачу можно решить легким трюком: ответ мы получим, если перевернем каждое слово в строке, после перевернем полностью всю строку и в конце избавимся от лишних пробелов.
Давайте рассмотрим задачу на примере `a good   example`:
- Сперва переворачиваем каждое слово внутри строки и получаем строку `a doog   elpmaxe`
- Следующим шагом переворачиваем всю строку и получаем `example   good a`
- В конце удаляем лишние пробелы внутри строки и получаем требующийся результат `example good a`

Для реализации этого алгоритма нам потребуется решить следующие подзадачи:
- Определение границ слов внутри строки
- Переворот слова/строки в обратном направлении
- Удаление лишних пробелов

Для удобства преобразуем входящую строку в массив byte (так как в ограничениях явно сказано, что в строке используются только)

Для решения первой подзадачи нам достаточно посимвольно пройтись по строке:
- Запоминаем индекс начала строки (исходно `startIdx := 0`).
- Как только мы доходим до первого пробела, считаем это границей нужного нам слова и переворачиваем часть строки от startIdx до текущего индекса.

Переворот строки мы реализуем в виде отдельной простой функции. Эта функция будет использоваться как для переворота отдельных слов внутри строки, так и для переворота целой строки,
```go
func reverseWord(s []byte, i, j int) {
	for i < j {
		s[i], s[j] = s[j], s[i]
		i++
		j--
	}
}
```

Метод по удалению лишних пробелов также вынесем в отдельную функцию: 
```go
func trimSpaces(bStr []byte) []byte {
	isStart := true
	j := 0
	for i := 0; i < len(bStr); i++ {
		if bStr[i] == byte(' ') && isStart {
			continue
		}

		bStr[j] = bStr[i]
		j++
		isStart = bStr[i] == byte(' ')
	}

	if bStr[j-1] == byte(' ') {
		j--
	}

	return bStr[:j]
}
```

{% include code-example.md go_path="go/solution.go" ts_path="ts/solution.ts" %}

### Оценка сложности

**По времени**

Для решения задачи нам потребуется несколько раз посимвольно пройтись по строке:
- Переворот каждого слова в строке
- Переворот целой строки
- Удаление лишних пробелов.

Итоговая сложность равна `O(n)`.

**По памяти**

Для решения задачи нам потребовалось преобразовать строку в массив байт. В зависимости от выбора языка программирования это операция может происходить как с выделением дополнительной памяти, так и без дополнительных аллокаций.

В общем случае оценить память можно в `O(n)`.