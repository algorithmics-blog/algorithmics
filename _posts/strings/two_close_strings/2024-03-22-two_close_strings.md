---
layout: post
title: "Определите, близки ли две строки"
complexity: medium
original_url: https://leetcode.com/problems/determine-if-two-strings-are-close/
tag: medium
---

## Оглавление

- [Описание задачи](#описание-задачи)
- [Ограничения](#ограничения)
- [Примеры](#примеры)
- [Решение](#решение)

---

## Описание задачи

Вам дано две строки. Верните `true`, если обе строки являются близкими, и `false` в противном случае.

Две строки считаются близкими, если одну из другой можно получить с помощью следующих операций.

**Операция 1**: Поменяйте местами любые два существующих символа (swap).
Например, `abcde` -> `aecdb` (букву `b` поменяли местами с буквой `e`).

**Операция 2**: Преобразуйте каждое появление одного существующего символа в другой существующий символ и сделайте то же самое с другим символом.
Например, `aacabb` -> `bbcbaa` (все буквы `a` превращаются в буквы `b`, а все буквы `b` превращаются в буквы `a`).

Вы можете использовать операции с любой строкой столько раз, сколько необходимо.

---

## Ограничения

- Длина каждого слова находится в диапазоне от 1 до 10<sup>5</sup>
- Оба слова содержат только строчные буквы латинского алфавита

---

## Примеры

{% tabs two_close_strings %}

{% tab two_close_strings Пример №1 %}

**Входные данные**: `word1 = "abc", word2 = "bca"`

**Ответ**: `true]`

**Объяснение**

Вы можете получить `word1` из `word2` за 2 операции. 

- Примените операцию 1: «abc» -> «acb» 
- Примените операцию 1: «acb» -> «bca»

{% endtab %}

{% tab two_close_strings Пример №2 %}

**Входные данные**: `word1 = "a", word2 = "aa"`

**Ответ**: `false`

**Объяснение**

Невозможно получить `word2` из `word1` или наоборот за любое количество операций.

{% endtab %}

{% tab two_close_strings Пример №3 %}

**Входные данные**: `word1 = "cabbba", word2 = "abbccc"`

**Ответ**: `true`

**Объяснение**

Вы можете получить `word1` из `word2 за 3 операции.

- Примените операцию 1: «cabbba» -> «caabbb» 
- Примените операцию 2: «caabbb» -> «baaccc» 
- Примените операцию 2: «baaccc» -> «abbccc»

{% endtab %}
{% endtabs %}

---

## Решение

Первая мысль, приходящая в голову, это написать некий алгоритм, который будет пытаться путем обозначенных операций привести одно слово к другому.
Проблема в том, что порядок выполнений операций может быть любой, а их количество не ограничено. 
Пойдя по этому пути, наш алгоритм будет работать очень долго в попытках перебрать все возможные варианты.
Нам нужно найти более хитрое и простое решение.

В первую очередь нужно внимательно посмотреть на примеры из задачи, а именно на третий пример.
Точнее даже на состояния первой строки при переходе во вторую.
Для удобства, разместим их в столбик и посчитаем частоту каждой буквы в слове.

```
cabbba — 1с, 2a, 3b
caabbb — 1c, 2a, 3b
baaccc — 1b, 2a, 3c
abbccc — 1a, 2b, 3c
```

При внимательном рассмотрении можно заметить, что при преобразовании строки, меняются буквы, но цифры частот остаются неизменными.
Назовем это сигнатурой частоты букв в слове.
То есть независимо от преобразований в слове всегда сохраняется следующая сигнатура частот — `[1, 2, 3]`.

На основе этого мы можем сформулировать два достаточных условия для того, чтобы две строки были близкими.

1. Сигнатура частоты букв в обоих словах должна быть одинаковой.
2. Все буквы из первого слова должны присутствовать во втором слове и наоборот.

Во всех противных случаях строки не являются близкими.

### Реализация

{% include code-example.md go_path="go/solution.go" ts_path="ts/solution.ts" %}

### Оценка сложности

**По времени**



**По памяти**

Сложность по памяти константная `O(1)`.
Хоть мы и выделяем память для хранения мап, но они имеют фиксированный размер, так как в английском алфавите всего 26 букв.
Таким образом выделение доп памяти можно считать константным.
