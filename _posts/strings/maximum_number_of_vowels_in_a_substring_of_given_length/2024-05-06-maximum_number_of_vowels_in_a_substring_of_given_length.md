---
layout: post
title: "Максимальное количество гласных в подстроке заданного размера"
complexity: medium
original_url: https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/
tag: medium
---

## Оглавление

- [Описание задачи](#описание-задачи)
- [Ограничения](#ограничения)
- [Примеры](#примеры)
- [Решение](#решение)

---

## Описание задачи

Дана строка `s` и максимальный размер подстроки `k`.
Необходимо написать функцию, которая вернет максимальное количество глассных в любой из подстрок строки `s` размером `k`.

---

## Ограничения

- Длина строки от 1 до 100000
- Строка состоит только из киррилических букв в нижнем регистре
- Размер подстроки находится в диапазоне от 1 до длины исходной строки `s`.

---

## Примеры

{% tabs maximum-number-of-vowels-in-a-substring-of-given-length %}

{% tab maximum-number-of-vowels-in-a-substring-of-given-length Пример №1 %}
**Входные данные**

```
s = "abciiidef"
k = 3
```

**Ответ**: `3`

В исходной строке есть подстрока длиной 3 состоящая исключительно из гласных `iii`
{% endtab %}

{% tab string_compression Пример №2 %}
**Входные данные**

```
s = "aeiou"
k = 2
```

**Ответ**: `2`

Исходная строк полностью состоит из гласных, поэтому любая подстрока длиной 2 будет также состоять из гласных.
{% endtab %}

{% tab string_compression Пример №3 %}
**Входные данные**

```
s = "leetcode"
k = 3
```

**Ответ**: `2`

В исходной строке есть несколько подстрок (`lee`/`eet`/`ode`), в любой из которых максимальное количество гласных равно 2.
{% endtab %}

{% endtabs %}

## Решение

Данная задача является ярким представителем коасса задач, которые решаются с помощью скользящего окна:
- Нам необходимо создать окно длиной `k` (исходно левая граница окна равна `0`, а правая - `k-1`)
- Двигать наше окно увеличивая левый и правый индекс на 1 на каждом шаге
- Считать сколько гласных попадает в наше окно на каждом шаге


Таким образом, исходно нам нужно посчитать сколько гласных будет в подстроке от `0` до `k-1` элемента, сохранив количество как промежуточный результат. 
После этого мы начнем двигать наше окно. Для того чтобы каждый раз не пересчитывать заново количество гласных, нам достаточно смотреть только на изменение подстроки:
- Если новый правый элемент окна является гласной — значит количество гласных относительно предыдущего окна нужно увеличить на один, так как мы включили в новой подстроке дополнительную гласную букву.
- Если старый левый элемент окна является гласной — значит количество гласных относительно предыдущего окна нужно уменьшить на один, так как мы исключили из подстроки гласную букву.

Для ускарения работы стоит не забывать о раннем выходе — если на каком-то шаге мы нашли подстроку длиной `k` из гласных, значит нам не нужно дальше анализировать всю строку до конца.

{% include code-example.md go_path="go/solution.go" ts_path="ts/solution.ts" %}

### Оценка сложности

`n` - количество элементов в строке.

**По времени**

Сложность по времени `O(n)`, так как мы гарантированно найдем ответ, перебрав полностью всю строку один раз.

**По памяти**

Сложность по памяти `O(1)`.