#  Roman to Integer (преобразование римских чисел в обычные)

### Оглавление

- [Описание](#description)
- [Брутфорс](#bruteforce_1) - в данной задаче брутфорс является достаточно оптимальным решением

---

### <a name="description"></a>Описание

- Ссылка на задачу https://leetcode.com/problems/roman-to-integer/
- Уровень #easy
- Входные данные: строка с римскими цифрами (I, V, X, L, C, D, M)
- Выходные данные: число
- Notice: есть правила уменьшения числа (например, число 4 - IV, а не IIII). Правила есть в описании задачи.

#### Примеры

###### Пример #1

- Входящие данные: "III"
- Выходящие: 3
- III = I + I + I = 1 + 1 + 1 = 3

###### Пример #2

- Входящие данные: "LVIII"
- Выходящие: 58
- LVIII = L + V + I + I + I = 50 + 5 + 1 + 1 + 1 = 58

###### Пример #3

- Входящие данные: "MCMXCIV"
- Выходящие: 1994
- MCMXCIV = M + (M - C) + (C - X) + (V - I) = 1000 + (1000 - 100) + (100 - 10) + (5-1) = 1994

#### Каких кейсов не хватает в примерах

- Символы не относящиеся к римскому алфавиту (в том числе нижний регистр для валидных символов)
  (p.s. в условиях задачи есть ограничение, гарантирующее отсутствие таких кейсов)

---

### <a name="bruteforce_1"></a> Брутфорс

#### Описание

Для решения данной задачи нам достаточно будет посимвольно пройтись по строке, преобразовать руны в цифры и суммировать их.
Главная сложность - учесть правила декремента (IV = 4, а не 6, так как меньшая цифра I стоит перед большей V).

#### Реализация

Для преобразования римских цифр создадим хеш-мапу у которой в качестве ключа будет руна с римской цифрой, а в качестве значения обычное число:
```go
var runeToIntegerMap = map[rune]int{
	'I': 1,
	'V': 5,
	'X': 10,
	'L': 50,
	'C': 100,
	'D': 500,
	'M': 1000,
}
```

Также, для удобства преобразования декрементов введем еще одну вспомогательную хеш-мапу, описывающую правила превращения римских цифр в число в случае декрементов:
```go
var runeToIntegerDecrementsMap = map[rune]map[rune]int{
	'I': {
		'V': 4,
		'X': 9,
	},
	'X': {
		'L': 40,
		'C': 90,
	},
	'C': {
		'D': 400,
		'M': 900,
	},
}
```
Таким образом, с помощью runeToIntegerDecrementsMap анализируя текущую и следующую цифру мы сможем легко получить правильное число.

Имея эти 2 вспомогательные хеш-мапы нам останется только пробежаться посимвольно по строке, преобразовать римскую цифру 
(проверяя не только текущий, но и следующий символ) в число и суммировать получившееся число с переменной-результатом:
```go
func romanToInt(s string) int {
	res := 0
	runes := []rune(s)

	for i := 0; i < len(runes); i++ {
		if i < len(runes)-1 {
			if possibleDecrements, exist := runeToIntegerDecrementsMap[runes[i]]; exist {
				realNum, found := possibleDecrements[runes[i+1]]
				if found {
					res += realNum
					i++
					continue
				}
			}
		}

		realNum := runeToIntegerMap[runes[i]]
		res += realNum
	}

	return res
}
```

#### Оценка алгоритма

###### Сложность

Чтобы преобразовать число нам потребуется проитерироваться по всей строке длиной n.
Никаких дополнительных действий, зависящих от длины строки  в алгоритме не происходит.


Так как при оценке алгоритма нам важен только порядок роста функции (т.е. приниматься будет только
главный член формулы, отбросив все константные затраты), итоговая оценка - **O(n)**

###### Память
Алгоритм не подразумевает выделение доп.памяти зависящей от длины строки n. Дополнительная память - является константной. 