# Генерация валидной скобочной последовательности (один вид скобок)

[leetcode](https://leetcode.com/problems/generate-parentheses/)

Сложность: Средняя

## Оглавление

- [Описание](#description)
- [Брутфорс решение](#solution_1)
- [Оптимизированный брутфорс](#solution_2)

---

## <a name="description"></a>Описание

Напишите функцию, которая будет генерировать все возможные валидные скобочные последовательности длиной `2n`.

Входные данные: int — количество пар скобок.

Выходные данные: массив строк — все возможные валидные скобочные последовательности длиной `2n`.

### Ограничения

- 1 <= n <= 8

### Примеры

#### Пример 1

```
Вход: 3
```

```
Ответ: ["((()))","(()())","(())()","()(())","()()()"]
```

#### Пример 2

```
Вход: 1
```

```
Ответ: ["()"]
```

## <a name="solution_1"></a> Брутфорс решение

Давайте разобьем задачу на 2 подзадачи:
- генерация всех возможных строк длиной 2n, состоящих из символов «(» и «)»;
- проверка строк на то, что они являются валидными скобочными последовательностями.


### Генерация всех возможных строк длиной 2n, состоящих из символов «(» и «)»

Достаточно тривиальная задача:
- Создаем исходный массив. В нашем случае из одного элемента, так как валидная скобочная последовательность может начинаться только с открывающей скобки.
- Запускаем цикл до `2 * n`, где `n` — количество пар скобок.
- В каждой итерации цикла проходимся по всем элементам предыдущего результата и добавляем 2 новых варианта с открывающей и закрывающей скобками.

```go
func generateAllPossibleParenthesis(n int) []string {
    combinations := make([]string, 0, 100)
    combinations = append(combinations, "(")
    
    for i := 1; i < n*2; i++ {
        newArray := make([]string, 0, len(combinations))
        for _, item := range combinations {
            newArray = append(newArray, item+"(")
            newArray = append(newArray, item+")")
        }
        
        combinations = newArray
    }
    
    return combinations
}
```

### Проверка строки на валидную скобочную последовательность

Эту задачу мы уже разбирали.
Чтобы не повторяться, возьмем готовое [решение](https://github.com/avivasyuta/algorithmics/blob/main/stack/valid_parentheses/description.md#solution) для проверки валидности скобочной последовательности.

В результате получим следующие решения:

- [Решение на GO](./go/solution_bruteforce.go)
- [Решение на TypeScript](./ts/solution_bruteforce.ts)


### Оценка сложности

**По времени**

Оптимальная сложность проверки строки на валидность — `O(n)`. В нашем случае все строки имеют длину `2n`, но итоговая сложность все равно будет равна `O(n)`.

Давайте оценим количество сгенерированных строк.
Каждый элемент строки кроме первого — произвольный символ из множества ["(", ")"], а количество символов в итоговой строке `2 * n`.
Таким образом, кол-во строк равно <code>2<sup>2n</sup></code>.

Итоговую сложность мы можем оценить как <code>n * (2<sup>2n</sup>)</code>.

**По памяти**

Самый большой расход памяти в нашем случае — хранение всех возможных строк.
Для этого нам понадобится массив строк, размером <code>2<sup>2n</sup></code>, каждый элемент которого равен `2 * n`.
То есть мы можем говорить о <code>n * 2<sup>2n</sup></code> дополнительной памяти.

### Комментарий

Чаще всего, в задачах с комбинаторикой решение с полным перебором всех возможных вариантов является сильно не оптимальным, так как скорость роста сложности решения относительно размера входных данных очень высока.
Так в этой задаче при n = 8 кол-во всех возможных вариантов строк — **32768** (<code>2<sup>15</sup></code>).


## <a name="solution_2"></a> Оптимизированный брутфорс

Основная проблема брутфорс решения — генерация большого количества заведомо невалидных строк.
Это можно исправить если мы перед добавлением очередного символа добавим проверки, откидывающие заведомо невалидные символы.

Задача сильно упрощается тем, что в условии сказано, что скобки могут быть только одного типа — круглые.
В этом случае мы можем использовать для валидации последовательности обычный счетчик.
Давайте опишем правила, когда мы можем добавлять разные скобки:
- Открывающую скобку мы можем добавить, если суммарное количество открытых скобок в строке не превышает числа `n` и если открывающих скобок в строке не меньше закрывающих.
- Закрывающую скобку мы можем добавить, если суммарное количество открытых скобок в строке больше чем закрывающих.

В этом решении не нужно постфактум проверять получившиеся скобки на валидность, так что мы сможем отбросить один из множителей в нашей оценке сложности.

[Решение на GO](./go/solution.go)
[Решение на TypeScript](./ts/solution.ts)

### Оценка сложности

**По времени**

В данном решении не нужна валидация последовательности. Ее мы заменили на проверку допустимости добавления открывающей/закрывающей скобки в момент генерации строки. 
Более того, за счет сохранения счетчика суммарного количества открытых и счетчика незакрытых скобок мы можем проводить эту проверку за константное время.

Количество сгенерированных строк равно <code>2<sup>2n-1</sup></code>.

> :❕: На самом деле количество строк сильно меньше, так как мы заранее отбрасываем все невалидные скобочные последовательности.
> Но, оценить их количество сильно сложнее. Валидно будет сказать, что в худшем случае сложность <code>2<sup>2n-1</sup></code>.

**По памяти**

Нам нужно выделить память для хранения всех результирующих строк. Каждая строка имеет длину 2*n.
Также, как и в оценке по сложности, валидно сказать, что количество строк сравнимо с <code>2<sup>2n-1</sup></code>.

Таким образом, сложность по памяти равна <code>n*2<sup>2n-1</sup></code>.
