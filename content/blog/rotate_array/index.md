---
layout: layouts/post.njk
title: Разворот массива
date: 2023-11-13
complexity: medium
original_url: https://leetcode.com/problems/rotate-array/description/
preview_image: /images/previews/rotate_array.webp
tags:
  - medium
  - array
  - two pointers
---
---

## Описание задачи

Дан целочисленный массив `nums`. Поверните массив вправо на `k` шагов, где `k` — неотрицательное число.

---

## Ограничения

- В массиве может быть от 1 до 10<sup>5</sup> элементов
- В качестве значений могут быть числа в диапазоне от -2<sup>31</sup> до 2<sup>31</sup> - 1
- `k` в диапазоне от 0 до 10<sup>5</sup>

---

## Примеры

{% tabs %}
{% tab "Пример №1" %}

**Входные данные**

```
nums = [1, 2, 3, 4, 5, 6, 7]
k = 3
```

**Ответ**: `[5, 6, 7, 1, 2, 3, 4]`

1. Сдвинуть на 1 шаг вправо: `[7,1,2,3,4,5,6]`.
2. Сдвинуть на 1 шаг вправо: `[6,7,1,2,3,4,5]`.
3. Сдвинуть на 1 шаг вправо: `[5,6,7,1,2,3,4]`.

{% endtab %}

{% tab "Пример №2" %}

**Входные данные**

```
nums = [-1, -100, 3, 99]
k = 2
```

**Ответ**: `[3, 99, -1, -100]`

1. Сдвинуть на 1 шаг вправо: `[99,-1,-100,3]`.
2. Сдвинуть на 1 шаг вправо: `[3,99,-1,-100]`.

{% endtab %}
{% endtabs %}

## Решение

Чтобы оптимально решить задачу, надо немного упростить условие.
Под поворотом массива на 1 подразумевается смещение всех элементов массива вправо на одну позицию.
Исходя из этого, если `k` будет равно или кратно длине массива, то после всех преобразований все элементы массива пройдут один «круг» и вернутся в исходное состояние.
Это означает, что мы можем отбросить повторяющиеся «круги» и взять только последний.

Для этого нужно найти остаток от деления `k` на длину массива. В результате мы найдем число `count`.
Именно на столько позиций надо сместить все элементы вправо.

Далее мы можем еще сильнее упростить алгоритм.
Если внимательно посмотреть, то можно обнаружить, что для получения результата надо произвести всего три операции:
- полностью развернуть исходный массив
- развернуть первые `k` элементов относительно их центра
- развернуть оставшиеся элементы относительно их центра

**Пример**

```
nums = [1,2,3,4,5,6,7], k = 3
```

Разворачиваем весь массив.

```
[7,6,5,4,3,2,1]
```

Разворачиваем первые 3 элемента относительно их центра.

```
[5,6,7,4,3,2,1]
```

Разворачиваем оставшиеся элементы относительно их центра.

```
[5,6,7,1,2,3,4]
```

{% renderFile "_includes/components/solution.njk", taskName = "rotate_array" %}

## Оценка сложности

`n` - количество элементов в массиве

**По времени**

Сложность по времени складывается из нескольких частей:
- `O(n/2)` — первый разворот массива
- `O(k/2)` — разворот первого подмассива, где `k < n`
- `O(m/2)` — разворот второго подмассива, где `m < n`

При этом `m + k = n`, поэтому в сумме сложность равна `O(n)`.

**По памяти**

Сложность по памяти `O(1)`, так как все изменения производятся `in-place`.
