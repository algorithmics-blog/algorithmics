---
layout: layouts/post.njk
title: Количество провинций
date: 2025-02-05
complexity: medium
original_url: https://leetcode.com/problems/number-of-provinces/description/
preview_image: /images/previews/number_of_provinces.webp
tags:
  - medium
  - graph
  - disjoint_set
---

---

## Описание задачи

Есть `n` городов, некоторые из которых соединены между собой.

Если город `a` напрямую соединен c городом `b`, а город `b` напрямую соединен с городом `c`, тогда города `a` и `c`
косвенно соединены между собой.

Провинция — это группа напрямую или косвенно связанных между собой городов.

Вам дана матрица `isConnected` размером `n` x `n`, где `isConnected[i][j] = 1`, если `i`-й город и `j`-й город напрямую
соединены, и `isConnected[i][j] = 0` в противном случае.

Верните общее количество провинций.

---

## Ограничения

- Размер матрицы `n` — это целое число в диапазоне от `1` до `200`
- В качестве значений в матрице используются только `1` b `0`
- `isConnected[i][j] == isConnected[j][i]`

---

## Примеры

{% tabs %}

{% tab "Пример №1" %}

**Входные данные**

```
isConnected = [[1,1,0],[1,1,0],[0,0,1]]
```

**Ответ**: `2`

{% endtab %}

{% tab "Пример №2" %}

**Входные данные**

```
isConnected = [[1,0,0],[0,1,0],[0,0,1]]
```

**Ответ**: `3`

{% endtab %}
{% endtabs %}

---

## Решение

У этой задачи достаточно много решений и все они достаточно сложные. Но мы можем легко решить задачу, если знать как
работает структура данных `DisjointSet` (также известная как `UnionFind`).

Подробно про реализацию структуры данных `DisjointSet` можно посмотреть [в этом посте](../disjoint_set).

Как только мы имеем реализованную структуру данных, задача становится крайне легкой.

Алгоритм решения:

- Создать инстанс структуры данных `DisjointSet`.
- Определить переменную `numberOfProvinces` равную `n` в начале состояния. Далее мы будем уменьшать ее значение при
  объединении городов в провинцию.
- Так как главная диагональ матрицы `isConnected` отображает соединение каждого города с самим собой, то мы можем ее не
  рассматривать. Также нам не требуется проверять всю матрицу так как `isConnected[i][j] == isConnected[j][i]`, поэтому
  будем перебирать элементы над главной диагональю. Для этого запустим цикл в цикле по `i` и `j` от `i = 0` и
  `j = i + 1`.
- Если два города соединены (`isConnected[i][j] == 1`) и они уже не находятся в одном множестве, то мы объединяем эти
  города в множество при помощи метода — то мы объединяем города `i` и `j` в одну провинцию.

В итоге после перебора элементов матрицы переменная `numberOfProvinces` будет показывать количество получившихся
провинций.

### Оценка сложности

**По времени**

- Перебор матрицы занимает <code>O(n<sup>2</sup>)</code>
- Поиск методом find занимает `O(n)`
- Объединение методом union занимает `O(n)`

Общая сложность по памяти <code>O(n<sup>2</sup>)</code>.

**По памяти**

Сложность `O(n)` для хранения состояния структуры `DisjointSet`.
