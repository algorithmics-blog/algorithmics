---
layout: layouts/post.njk
title: Максимальное количество гласных в подстроке заданного размера
date: 2024-05-06
complexity: medium
original_url: https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/
preview_image: /images/previews/maximum_number_of_vowels_in_a_substring_of_given_length.webp
tags:
  - medium
  - string
  - sliding window
---
---

## Описание задачи

Дана строка `s` и максимальный размер подстроки `k`.
Необходимо написать функцию, которая вернет максимальное количество глассных в любой из подстрок строки `s` размером `k`.

---

## Ограничения

- Длина строки от 1 до 100000
- Строка состоит только из латинских букв в нижнем регистре
- Размер подстроки находится в диапазоне от 1 до длины исходной строки `s`.

---

## Примеры

{% tabs %}

{% tab "Пример №1" %}

**Входные данные**

```
s = "abciiidef"
k = 3
```

**Ответ**: `3`

В исходной строке есть подстрока длиной 3 состоящая исключительно из гласных `iii`

{% endtab %}

{% tab "Пример №2" %}

**Входные данные**

```
s = "aeiou"
k = 2
```

**Ответ**: `2`

Исходная строк полностью состоит из гласных, поэтому любая подстрока длиной 2 будет также состоять из гласных.

{% endtab %}

{% tab "Пример №3" %}

**Входные данные**

```
s = "leetcode"
k = 3
```

**Ответ**: `2`

В исходной строке есть несколько подстрок (`lee`/`eet`/`ode`), в любой из которых максимальное количество гласных равно 2.

{% endtab %}

{% endtabs %}

## Решение

Данная задача является ярким представителем класса задач, которые решаются с помощью скользящего окна:
- Нам необходимо создать окно длиной `k` (исходно левая граница окна равна `0`, а правая - `k-1`)
- Двигать наше окно увеличивая левый и правый индекс на 1 на каждом шаге
- Считать сколько гласных попадает в наше окно на каждом шаге


Таким образом, исходно нам нужно посчитать сколько гласных будет в подстроке от `0` до `k-1` элемента, сохранив количество как промежуточный результат. 
После этого мы начнем двигать наше окно. Для того чтобы каждый раз не пересчитывать заново количество гласных, нам достаточно смотреть только на изменение подстроки:
- Если новый правый элемент окна является гласной — значит количество гласных относительно предыдущего окна нужно увеличить на один, так как мы включили в новой подстроке дополнительную гласную букву.
- Если старый левый элемент окна является гласной — значит количество гласных относительно предыдущего окна нужно уменьшить на один, так как мы исключили из подстроки гласную букву.

Для ускорения работы стоит не забывать о раннем выходе — если на каком-то шаге мы нашли подстроку длиной `k` из гласных, значит нам не нужно дальше анализировать всю строку до конца.

{% renderFile "_includes/components/solution.njk", taskName = "maximum_number_of_vowels_in_a_substring_of_given_length" %}

### Оценка сложности

`n` - количество элементов в строке.

**По времени**

Сложность по времени `O(n)`, так как мы гарантированно найдем ответ, перебрав полностью всю строку один раз.

**По памяти**

Сложность по памяти `O(1)`.