---
layout: layouts/post.njk
title: Максимальная сумма парных элементов связного списка
date: 2024-10-02
complexity: medium
original_url: https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/description/
preview_image: /images/previews/maximum_twin_sum_of_a_linked_list.webp
tags:
  - medium
  - linked list
---
---

## Описание задачи

Реализуйте функцию, которая будет искать максимальную сумму парных элементов связного списка.

Парный элемент для i'го считается элемент с индексом n-1-i (где 0 <= i <= (n / 2) - 1). То есть, для первого элемента списка парным будет считаться последний элемент списка, для второго - предпоследний и так далее.

---

## Ограничения

- Список всегда имеет четное количество элементов
- Количество элементов лежит в диапазоне от 2 до 100000
- Значение элемента лежит в диапазоне от 1 до 100000

---

## Примеры

{% tabs %}

{% tab "Пример 1" %}

**Элементы списка**: `[5,4,2,1]`

**Ответ**: `6`

**Пояснение**: В списке есть 2 пары элементов: `[5, 1]` и `[4, 2]`. Сумма обоих пар равна 6. 

{% endtab %}

{% tab "Пример 2" %}

**Входные данные**: `[4,2,2,3]`

**Ответ**: `7`

**Пояснение**: В списке есть 2 пары элементов: `[4, 3]` и `[2, 2]`. Максимальная сумма равна 7.

{% endtab %}

{% tab "Пример 3" %}

**Входные данные**: `[1,100000]`

**Ответ**: `100001`

{% endtab %}
{% endtabs %}

---

## Решение

Основная сложность этой задачи заключается в использовании связного списка в качестве структуры данных: мы не знаем длину списка и не можем быстро обращаться к элементам по индексу, из-за чего не получается быстро находить парный элемент для текущего узла.

Первая идея, которая приходит в голову — отказаться от использования связного списка в пользу массива. Это сделать несложно: достаточно один раз пройти по всему списку и перенести все элементы в массив:
```go
list := []int{head.Val}
for cur := head.Next; cur != nil; cur = cur.Next {
    list = append(list, cur.Val)
}
```
Теперь, имея на руках слайс, мы можем легко находить парные элементы, и задача сводится к простому поиску максимума среди сумм парных элементов. Более того, решение можно улучшить, сэкономив память, ведь необязательно превращать весь список в массив. Достаточно переложить первую половину списка в стек, а затем пройти по второй половине, доставая для каждого следующего элемента его пару из стека.

Однако возникает другая проблема: как я уже упоминал, основное ограничение — это незнание длины списка, а значит, мы не можем сразу определить, где находится его середина. Это ограничение можно обойти с помощью небольшой хитрости, используя два указателя:
- `currentListElement` — будем перемещать по списку последовательно.
- `oddElementList` — будем двигать через два элемента за раз. В связном списке это делается следующим образом:
```go
oddElementList = oddElementList.Next.Next
```

Таким образом, когда указатель oddElementList достигнет конца списка, указатель currentListElement будет указывать на начало второй половины нашего списка. Полное условие цикла будет выглядеть следующим образом:
```go
for oddElementList != nil && oddElementList.Next != nil {
    stack = append(stack, currentListElement.Val)
    currentListElement = currentListElement.Next
    oddElementList = oddElementList.Next.Next
}
```

После этого останется только пройтись до конца списка указателем currentListElement, доставая для каждого следующего элемента его пару из стека и находя максимальную сумму.

Но, вероятнее всего, в задаче не подрузомевалось использование других структур данных (хотя, в явном виде такого ограничения нет). Поэтому мы можем попробовать решить задачу только с использованием связных списков.

Чтобы быстро находить пары, можно создать вспомогательный список, развернутый в обратном порядке. Для изменения порядка списка можно написать простую функцию (изменение происходит in-place без создания нового списка):
```go
func reverseList(head *ListNode) *ListNode {
	var newHead *ListNode = nil
	for head != nil {
		next := head.Next
		head.Next, newHead = newHead, head
		head = next
	}

	return newHead
}
```

Как и в случае со стеком, можно развернуть не весь список, а только одну его половину. Итоговое решение будет очень похоже на решение со стеком, только вместо стека мы будем использовать первую половину списка, развернутую в обратном порядке.

Данное решение будет более оптимальным по памяти, так как изменение порядка происходит in-place и не требует дополнительного пространства под массив или стек.

---

### Реализация

{% renderFile "_includes/components/solution.njk", taskName = "remove_stars" %}

### Оценка сложности

**По времени**

Для решения задачи нам достаточно проитерироваться по исходному списку. Не смотря на то, что в наших решениях мы сделали это несколько раз, с точки зрения алгоритмической сложности, итоговая сложность будет равна `O(n)`.

**По памяти**

В случае решения через вспомогательный массив или стек, дополнительную память можно оценить в `O(n)`.

В решении с разворотом половины списка дополнительная память равна `O(1)`.
