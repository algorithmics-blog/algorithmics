---
layout: layouts/post.njk
title: Имплементация функции возведения в степень
date: 2023-09-28
complexity: medium
original_url: https://leetcode.com/problems/powx-n/description/
preview_image: /images/previews/powx_n.webp
tags:
  - medium
  - math
  - recursion
---
---

## Описание задачи

Напишите функцию, которая будет возводить число `x` в степень `n`.

Входные данные: x (float64), n (int)

Выходные данные: float64 (результат возведения числа x в степень n)

---

## Ограничения

- -100.0 < x < 100.0
- -2<sup>31</sup> <= n <= 2<sup>31</sup>-1
- -10<sup>4</sup> <= x<sup>n</sup> <= 10<sup>4</sup>
- При `x = 0`, `n` - неотрицательные

---

## Примеры

{% tabs %}
{% tab "Пример №1" %}

**Входные данные**

```
x = 2.00000
n = 10
```

**Ответ**: `1024.00000`

{% endtab %}

{% tab "Пример №2" %}

**Входные данные**

```
x = 2.10000
n = 3
```

**Ответ**: `9.26100`

{% endtab %}

{% tab "Пример №3" %}

**Входные данные**

```
x = 2.00000
n = -2
```

**Ответ**: `0.25000`

{% endtab %}
{% endtabs %}

---

## Брутфорс решение

Так как возведение в степень — результат умножения числа `x` само на себя `n` раз, брутфорс решение можно написать используя обычный цикл (пока предположим, что `n` всегда > 0):
```go
res := x

for ; n > 1; n-- {
    res *= x
}

return res
```

Для того чтобы учесть кейсы с отрицательным `n`, вспомним свойство степеней.

$$ x^{-n} = {1 \over x^n} $$

Таким образом, вынесем возведение в положительную степень в отдельную функцию.

```go
func powAbsNBruteforce(x float64, n int) float64 {
	if n == 0 {
		return 1
	}

	if n == 1 {
		return x
	}

	res := x

	for ; n > 1; n-- {
		res *= x
	}

	return res
}
```

А в основной функции добавим проверку на отрицательность `n`.

```go
if n < 0 {
    return 1 / powAbsNBruteforce(x, -1*n)
}

return powAbsNBruteforce(x, n)
```

Итоговое решение.

{% renderFile "_includes/components/solution.njk", taskName = "powx_n", fileName="bruteforce" %}

### Оценка сложности

**По времени**

Для вычисления степени нам нужно произвести `n` умножений, то есть сложность - `O(n)`.

**По памяти**

`O(1)` — дополнительная память константна.

---

## Оптимальное решение

Мы можем сократить кол-во умножений, если вспомним одно из свойств степеней.

$$ x^n = {(x * x)^{n \over 2}} $$

Например:
<code>2<sup>8</sup> = 4<sup>4</sup> = 16<sup>2</sup> = 256</code>.

Таким образом, мы можем переписать нашу функцию на рекурсивную, не забывая отдельно обработать кейс с нечетной степенью:

{% renderFile "_includes/components/solution.njk", taskName = "powx_n" %}

### Оценка сложности

**По времени**

В этом подходе на каждой итерации рекурсии мы возводим число в квадрат, вдвое снижая количество требуемых умножений.
То есть итоговая сложность — `O(log n)`.

**По памяти**

`O(1)` — дополнительная память константна.
