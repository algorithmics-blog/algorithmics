---
layout: layouts/post.njk
title: Система поиска подсказок
date: 2024-29-11
complexity: medium
original_url: https://leetcode.com/problems/search-suggestions-system/description/
preview_image: /images/previews/search_suggestions_system.webp
tags:
  - medium
  - trie
  - binary search
---
---

## Описание задачи

Дан массив строк `products`, представляющий доступные названия продуктов, и строка `searchWord`, представляющая искомое слово, вводимое пользователем.

Реализуйте функцию, которая возвращает массив массивов, где:

- Каждый подмассив содержит список подсказок для соответствующего префикса строки `searchWord`. Первый подмассив соответствует префиксу из первого символа строки `searchWord`, второй — префиксу из первых двух символов, и так далее.
- Каждый подмассив включает до трех продуктов из products, отсортированных в лексикографическом порядке.
- Если для какого-либо префикса не найдено совпадений, соответствующий подмассив должен быть пустым.

---

## Ограничения

- 1 <= products.length <= 1000 — количество продуктов.
- 1 <= products[i].length <= 3000 — длина каждой строки продукта.
- 1 <= searchWord.length <= 1000 — длина строки поиска.
- Все строки состоят только из строчных латинских букв.

---

## Примеры

{% tabs %}

{% tab "Пример 1" %}

**Продукты**: `products = ["mobile","mouse","moneypot","monitor","mousepad"]`

**Искомое слово**: `searchWord = "mouse"`

**Ответ**: `[`

`        ["mobile","moneypot","monitor"], // список подсказок для префикса "m"`

`        ["mobile","moneypot","monitor"], // список подсказок для префикса "mo"`

`        ["mouse","mousepad"], // список подсказок для префикса "mou"`

`        ["mouse","mousepad"], // список подсказок для префикса "mous"`

`        ["mouse","mousepad"], // список подсказок для префикса "mouse"`

`]`


{% endtab %}

{% tab "Пример 2" %}

**Продукты**: `products = ["havana"]`

**Искомое слово**: `searchWord = "havana"`

**Ответ**: `[`

`        ["havana"], // список подсказок для префикса "h"`

`        ["havana"], // список подсказок для префикса "ha"`

`        ["havana"], // список подсказок для префикса "hav"`

`        ["havana"], // список подсказок для префикса "hava"`

`        ["havana"], // список подсказок для префикса "havan"`

`        ["havana"], // список подсказок для префикса "havana"`

`]`

{% endtab %}


{% endtabs %}

---

## Решение через префиксное дерево

Задачи, в которых необходимо находить строки по заданному префиксу, обычно идеально решаются с использованием структуры данных под названием "[Префиксное дерево (Trie)](https://t.me/algorithmics_cl/128)".

Для этого нам необходимо имплементировать саму структуру данных и метод, который по заданному префиксу будет возвращать конечные слова, начинающиеся с этого префикса.
Чтобы оптимизировать поиск и избежать выполнения сортировки в процессе работы, помимо хеш-таблицы с дочерними узлами можно хранить отсортированный список ключей. Этот список будет формироваться или обновляться во время добавления новых слов.

Таким образом, решение задачи включает два этапа:

- Преобразование входящего массива products в префиксное дерево.
- Последовательный обход строки searchWord по символам с извлечением подсказок для каждого префикса.

### Реализация

{% renderFile "_includes/components/solution.njk", taskName = "search_suggestions_system", fileName = "solution_trie" %}

### Оценка сложности

**По времени**

#### Преобразование массива в префиксное дерево:

- Для добавления слова длиной m в дерево потребуется `O(m)` операций.
- Таким образом, для массива из n слов общее время составит `O(m * n)`, где `m` — длина самого длинного слова в products, а `n` — количество слов в массиве.

#### Поиск подсказок по префиксу:

- Поиск подсказок по префиксу можно оценить в `O(m)`, где `m` — длина самого длинного слова в products
- Так как searchWord имеет длину s, для каждого из ее s префиксов нужно выполнить поиск подсказок. В сумме поиск займет `O(s * m)`.

#### Итоговая оценка сложности:
Сложность всего алгоритма можно выразить как: `O(m*n+s*m)` где:
- `m` — длина самого длинного слова в `products`,
- `n` — количество слов в массиве `products`,
- `s` — длина строки `searchWord`.

**По памяти**

Для решения задачи нам потребуется память под префиксное дерево. В худшем случае ее можно оценить в `O(m*n)`, где `m` - длина самого длинного слова в `products`, а `n` - длина массива `products`.

## Возможные оптимизации префиксного дерева

### Избегаем лишних поисков в глубину 

Первое, что бросается в глаза, — необходимость для каждого префикса спускаться вниз по дереву вплоть до листовых узлов. Это приводит к дублирующейся работе, так как для многих префиксов списки подсказок будут идентичны. Особенно это заметно на длинных префиксах, где вариативность подсказок значительно ниже, чем для более коротких префиксов.

Чтобы избежать этого, можно изменить подход: вместо того чтобы начинать поиск с самого короткого префикса и двигаться вниз, мы можем стартовать с максимального префикса и подниматься вверх по дереву. В этом случае слова будут "всплывать" из нижележащих узлов к вышележащим, а спускаться вниз потребуется только в тех случаях, когда вариативность дочерних узлов у вышележащей ноды увеличивается по сравнению с текущей.

Хотя такая оптимизация может улучшить производительность в реальных условиях, она не изменит асимптотическую сложность алгоритма.

### Оптимизация за счет памяти

В реальной жизни память обычно дешевле, чем процессорное время, а операции чтения выполняются гораздо чаще, чем операции записи. Более того, размер каталога продуктов, как правило, невелик. Учитывая эти вводные, можно существенно оптимизировать решение задачи, модифицировав префиксное дерево.

Мы можем хранить в каждой ноде дерева дополнительный массив suggestions, содержащий ссылки на итоговые продукты, которые будут возвращаться в качестве подсказок. Это позволит избежать поиска в глубину при извлечении подсказок, что сократит сложность с `O(s * m)` до `O(s)`, где `s` — длина строки `searchWord`. В реальных условиях такая оптимизация может значительно улучшить производительность, используя дешевый ресурс памяти.

Однако такая модификация влияет на сложность вставки слова в дерево. Теперь вставка потребует времени `O(m * n * m)`, так как для каждой затронутой ноды при добавлении нового слова нужно будет пересчитывать массив подсказок, спускаясь по дереву.

В рамках данной задачи, где различия между нагрузками на чтение и запись не учитываются, эта оптимизация скорее ухудшает производительность. Увеличение затрат на вставку может перевесить преимущества, особенно при большом количестве операций записи.

## Решение через бинарный поиск

Особенность данной задачи заключается в том, что преобразование исходного массива в другую структуру данных можно рассматривать как запись (пишущую нагрузку), а поиск — как чтение (читающую нагрузку). Таким образом, в рамках этой задачи запись значительно превышает чтение, что нетипично для классических поисковых систем.

Чтобы достичь оптимального результата, необходимо минимизировать модификацию исходного массива. Если отсортировать массив products, все подсказки для одного префикса будут находиться рядом друг с другом. Это позволяет упростить задачу поиска подсказок по префиксу следующим образом:

- Найти в отсортированном массиве индекс первого слова, которое начинается с заданного префикса.
- Проверить два следующих слова за найденным индексом, чтобы определить, соответствуют ли они нужному префиксу.

Для нахождения первого слова с нужным префиксом можно использовать модифицированный бинарный поиск, который эффективно отыскивает начальную позицию префикса в отсортированном массиве.

Этот подход позволяет минимизировать изменения исходного массива, сохраняя оптимальную производительность поиска благодаря использованию сортировки и бинарного поиска.

Данную реализацию можно дополнительно оптимизировать:
- В отсортированном массиве подсказки для следующего префикса гарантированно будут находиться либо в том же диапазоне, что и для текущего префикса, либо правее. Это позволяет ограничить область бинарного поиска, начиная с предыдущего диапазона, вместо выполнения поиска по всему массиву. 
- Линейный проход назад в процессе бинарного поиска для определения первого индекса слова, начинающегося с заданного префикса, можно устранить. Для этого можно модифицировать бинарный поиск так, чтобы он сразу возвращал индекс первого подходящего элемента.

### Реализация

{% renderFile "_includes/components/solution.njk", taskName = "search_suggestions_system", fileName = "solution" %}

### Оценка сложности

**По времени**

Нам предварительно необходимо отсортировать исходный массив, а после совершить `s` бинарных поисков.
Таким образом итоговую сложность можно оценить в `O(s*log(n))`, где `n` длина массива `products`, а `s` — длина `searchWord`.

**По памяти**

Память для данной реализации константна - `O(1)`.