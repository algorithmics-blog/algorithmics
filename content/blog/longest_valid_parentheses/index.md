---
layout: layouts/post.njk
title: Самая длинная подстрока, являяющаяся валидной скобочной последовательностью
date: 2024-06-28
complexity: hard
original_url: https://leetcode.com/problems/longest-valid-parentheses/description/
preview_image: /images/previews/longest_valid_parentheses.webp
tags:
  - hard
  - stack
---
---

## Описание задачи

Напишите функцию для поиска самой длинной подстроки, являющейся правильной скобочной последовательностью.

Входные данные: строка `s`.

Выходные данные: длина самой большой подстроки, являющейся валидной скобочной последовательностью.

---

## Ограничения

- Длина каждой строки от 0 до 30000 символов
- Строка состоит из символов `(` и `)`

---

## Примеры

{% tabs %}
{% tab "Пример №1" %}

**Входные данные**: `s = "(()"`

**Ответ**: `2`

**Пояснения**: Самая длинная правильная скобочная последовательность - `()`

{% endtab %}

{% tab "Пример №2" %}

**Входные данные**: `s = ")()())"`

**Ответ**: `4`

**Пояснения**: Самая длинная правильная скобочная последовательность - `()()`

{% endtab %}

{% tab "Пример №3" %}

**Входные данные**: `s = ""`

**Ответ**: `0`

{% endtab %}
{% endtabs %}

---

## Решение

### Брутфорс (скользящее окно)

Первая идея решения задачи, как обычно, — это брутфорс. Поскольку нам нужно найти самую длинную подстроку, мы можем начать с подстрок максимальной длины и постепенно переходить к более коротким, пока не найдем первую подходящую подстроку и не вернем её длину.

Для этого нам поможет метод скользящего окна: устанавливаем левую границу на первый элемент, а правую — на длину текущей подстроки. Двигаем окно слева направо, одновременно увеличивая левую и правую границы. Если не будет найдено ни одной подходящей подстроки заданной длины, уменьшаем длину на единицу и снова начинаем проверять все возможные подстроки.

Проверку на валидность можно реализовать с помощью простого счетчика (так как по условиям задачи у нас только один вид скобок) или же с использованием [стека](https://algorithmics-blog.github.io/blog/valid_parentheses/).

Основная проблема брутфорса — это скорость алгоритма. В худшем случае нам придется перебрать все возможные подстроки. ChatGPT подсказывает, что количество подстрок можно рассчитать с помощью формулы `n(n+1)/2`. . Каждую подстроку придется независимо проверять на валидность — сложность такой проверки `O(len(substr))`.

### Оптимальное решение

На самом деле задача решается достаточно легко: максимальная валидная скобочная последовательность — это максимальное расстояние между невалидными подстроками.

То есть, если мы сможем «вырезать» из строки валидные скобочные последовательности, сохранив индексы элементов, то самая большая разница между двумя соседними индексами и будет искомым числом. В этом нам поможет структура данных стек.

Для решения задачи мы будем идти посимвольно по исходной строке:

- Если текущий символ — открывающая скобка, помещаем индекс символа в стек.
- Если текущий символ — закрывающая скобка, достаем из стека последний индекс. Если при этом стек становится пустым, добавляем текущий индекс в стек, так как потенциально текущая позиция может служить началом для следующей подстроки. Если же стек остается непустым, вычисляем разницу между текущим индексом и индексом на вершине стека (чтобы не нужно было дополнительно проходиться по стеку).

Исходно в стек помещаем число -1, которое служит для обработки случая, когда вся строка является корректной подстрокой скобок.

В итоге:

{% renderFile "_includes/components/solution.njk", taskName = "longest_valid_parentheses" %}

### Оценка сложности

**По времени**

Для оптимального решения нам необходимо один раз пройтись по переданной нам строке. То есть сложность по времени — `O(n)`.

**По памяти**

В нашем оптимальном решении мы выделили дополнительную память на стек. В худшем случае в стек попадут все символы строки, то есть сложность по памяти — `O(n)`.
