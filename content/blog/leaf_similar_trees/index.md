---
layout: layouts/post.njk
title: Листоподобные деревья
date: 2024-06-25
complexity: easy
original_url: https://leetcode.com/problems/leaf-similar-trees/description/
preview_image: /images/previews/leaf_similar_trees.webp
tags:
  - easy
  - tree
  - binary tree
---

---

## Описание задачи

Дано два бинарных дерева.

Все листовые узлы дерева образуют последовательность значений.

![Последовательность значений листьев](/images/resources/leaf_similar_tree/tree_1.png)

Например, для дерева выше последовательность значений будет равна `(6, 7, 4, 9, 8)`.

Два бинарных дерева считаются листоподобными, если последовательность значений их листьев одинакова.

Напишите функцию, которая возвращает `true` тогда и только тогда, когда два заданных дерева являются листоподобными.

---

## Ограничения

- Количество узлов в каждом дереве находится в диапазоне `[1, 200]`
- Узлы обоих деревьев имеют значения в диапазоне `[0, 200]`

---

## Примеры

{% tabs %}
{% tab "Пример №1" %}

**Входные данные**:

![Листоподобные деревья](/images/resources/leaf_similar_tree/tree_2.png)

**Ответ**: `true`

{% endtab %}

{% tab "Пример №2" %}

**Входные данные**:

![Не листоподобные деревья](/images/resources/leaf_similar_tree/tree_3.png)

**Ответ**: `false`

{% endtab %}
{% endtabs %}

---

## Решение

Для решения задачи нам необходимо собрать последовательность всех листовых узлов в обоих деревьях и сравнить их.

Для этого мы реализуем отдельную функцию `getSequence`, которая будет формировать последовательность значений листовых
узлов для переданного дерева.

Функция осуществляет классический обход дерева в глубину DFS (Depth First Search) и когда встречает листовой узел (узел,
у которого нет потомков), то добавляет его значение в строку `sequence`, разделяя значения точкой с запятой.
Предварительно мы определяем переменную `sequence`, равную пустой строке, и управляем ее значением через замыкание.

Вместо строки можно было бы использовать массивы, но после вычисления массивом их пришлось бы сравнивать итерируясь по
всем элементам, что дало бы дополнительных `k` операций. Строки же можно просто сравнить между самой через `==`.

### Реализация

{% renderFile "_includes/components/solution.njk", taskName = "leaf_similar_trees" %}

### Оценка сложности

- `n1` — количество узлов в первом дереве
- `n2` — количество узлов во втором дереве
- `h1` — высота первого дерева
- `h2` — высота второго дерева

**По времени**

`O(n1 + n2)`, так как нам нужно перебрать все элементы в дереве.

**По памяти**

Так как мы храним последовательности листовых узлов в виде строки, то выделяемую память мы считаем константной.
Однако, это рекурсивный алгоритм поэтому нужно учесть память используемую стеком вызовов. 

Таким образом сложность по памяти равна `O(h1 + h2)`.
